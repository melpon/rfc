<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC3493 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3493.xml">
<!ENTITY RFC3542 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3542.xml">
<!ENTITY RFC3758 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3758.xml">
<!ENTITY RFC4895 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4895.xml">
<!ENTITY RFC4960 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4960.xml">
<!ENTITY RFC5061 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5061.xml">
<!ENTITY RFC0768 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0768.xml">
<!ENTITY RFC0793 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0793.xml">
<!ENTITY RFC1644 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1644.xml">
<!ENTITY RFC6083 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6083.xml">
<!ENTITY RFC6247 SYSTEM "https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6247.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<rfc submissionType="IETF" number="6458" category="info" consensus="yes" ipr="pre5378Trust200902">
	<!-- Generated by id2xml 1.4.4 on 2018-11-20T06:57:15Z -->
	<?rfc compact="yes"?>
	<?rfc text-list-symbols="o*+-"?>
	<?rfc subcompact="no"?>
	<?rfc sortrefs="no"?>
	<?rfc symrefs="yes"?>
	<?rfc strict="yes"?>
	<?rfc toc="yes"?>
	<front>
	<title abbrev="SCTP Sockets API">Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)</title>
	<author fullname="Randall R. Stewart" initials="R." surname="Stewart">
	<organization>Adara Networks</organization>
	<address><postal><street>Chapin, SC  29036</street>
	<street>USA</street>
	</postal>
	<email>randall@lakerest.net</email>
	</address>
	</author>

	<author fullname="Michael Tuexen" initials="M." surname="Tuexen">
	<organization abbrev="Muenster Univ. of Appl. Sciences">Muenster University of Applied Sciences</organization>
	<address><postal><street>Stegerwaldstr. 39</street>
	<street>48565 Steinfurt</street>
	<street>Germany</street>
	</postal>
	<email>tuexen@fh-muenster.de</email>
	</address>
	</author>

	<author fullname="Kacheong Poon" initials="K." surname="Poon">
	<organization>Oracle Corporation</organization>
	<address><email>ka-cheong.poon@oracle.com</email>
	</address>
	</author>

	<author fullname="Peter Lei" initials="P." surname="Lei">
	<organization>Cisco Systems, Inc.</organization>
	<address><postal><street>9501 Technology Blvd.</street>
	<street>West Office Center</street>
	<street>Rosemont, IL  60018</street>
	<street>USA</street>
	</postal>
	<email>peterlei@cisco.com</email>
	</address>
	</author>

	<author fullname="Vladislav Yasevich" initials="V." surname="Yasevich">
	<organization>HP</organization>
	<address><postal><street>110 Spitrook Rd.</street>
	<street>Nashua, NH  03062</street>
	<street>USA</street>
	</postal>
	<email>vladislav.yasevich@hp.com</email>
	</address>
	</author>

	<date month="December" year="2011"/>
	<abstract><t>
   This document describes a mapping of the Stream Control Transmission
   Protocol (SCTP) into a sockets API.  The benefits of this mapping
   include compatibility for TCP applications, access to new SCTP
   features, and a consolidated error and event notification scheme.</t>

	</abstract>
	</front>

	<middle>
	<section title="Introduction" anchor="section-1"><t>
   The sockets API has provided a standard mapping of the Internet
   Protocol suite to many operating systems.  Both TCP <xref target="RFC0793"/> and UDP
   <xref target="RFC0768"/> have benefited from this standard representation and access
   method across many diverse platforms.  SCTP is a new protocol that
   provides many of the characteristics of TCP but also incorporates
   semantics more akin to UDP.  This document defines a method to map
   the existing sockets API for use with SCTP, providing both a base for
   access to new features and compatibility so that most existing TCP
   applications can be migrated to SCTP with few (if any) changes.</t>

	<t>
   There are three basic design objectives:</t>

	<t><list style="numbers"><t>Maintain consistency with existing sockets APIs: We define a
       sockets mapping for SCTP that is consistent with other sockets
       API protocol mappings (for instance UDP, TCP, IPv4, and IPv6).</t>

	<t>Support a one-to-many style interface: This set of semantics is
       similar to that defined for connectionless protocols, such as
       UDP.  A one-to-many style SCTP socket should be able to control
       multiple SCTP associations.  This is similar to a UDP socket,
       which can communicate with many peer endpoints.  Each of these
       associations is assigned an association identifier so that an<vspace blankLines="1"/>
	application can use the ID to differentiate them.  Note that SCTP
       is connection-oriented in nature, and it does not support
       broadcast or multicast communications, as UDP does.
	</t>

	<t>Support a one-to-one style interface: This interface supports a
       similar semantics as sockets for connection-oriented protocols,
       such as TCP.  A one-to-one style SCTP socket should only control
       one SCTP association.  One purpose of defining this interface is
       to allow existing applications built on other connection-oriented
       protocols to be ported to use SCTP with very little effort.
       Developers familiar with these semantics can easily adapt to
       SCTP.  Another purpose is to make sure that existing mechanisms
       in most operating systems that support sockets, such as select(),
       should continue to work with this style of socket.  Extensions
       are added to this mapping to provide mechanisms to exploit new
       features of SCTP.</t>

	</list>
	</t>

	<t>
   Goals 2 and 3 are not compatible, so this document defines two modes
   of mapping, namely the one-to-many style mapping and the one-to-one
   style mapping.  These two modes share some common data structures and
   operations, but will require the use of two different application
   programming styles.  Note that all new SCTP features can be used with
   both styles of socket.  The decision on which one to use depends
   mainly on the nature of the applications.</t>

	<t>
   A mechanism is defined to extract an SCTP association from a one-to-
   many style socket into a one-to-one style socket.</t>

	<t>
   Some of the SCTP mechanisms cannot be adequately mapped to an
   existing socket interface.  In some cases, it is more desirable to
   have a new interface instead of using existing socket calls.
   Section 9 of this document describes these new interfaces.</t>

	<t>
   Please note that some elements of the SCTP sockets API are declared
   as deprecated.  During the evolution of this document, elements of
   the API were introduced, implemented, and later on replaced by other
   elements.  These replaced elements are declared as deprecated, since
   they are still available in some implementations and the replacement
   functions are not.  This applies especially to older versions of
   operating systems supporting SCTP.  New SCTP socket implementations
   must implement at least the non-deprecated elements.  Implementations
   intending interoperability with older versions of the API should also
   include the deprecated functions.</t>

	</section>

	<section title="Data Types" anchor="section-2"><t>
   Whenever possible, Portable Operating System Interface (POSIX) data
   types defined in <xref target="IEEE-1003.1-2008"/> are used: uintN_t means an
   unsigned integer of exactly N bits (e.g., uint16_t).  This document
   also assumes the argument data types from POSIX when possible (e.g.,
   the final argument to setsockopt() is a socklen_t value).  Whenever
   buffer sizes are specified, the POSIX size_t data type is used.</t>

	</section>

	<section title="One-to-Many Style Interface" anchor="section-3"><t>
   In the one-to-many style interface, there is a one-to-many
   relationship between sockets and associations.</t>

	<section title="Basic Operation" anchor="section-3.1"><t>
   A typical server in this style uses the following socket calls in
   sequence to prepare an endpoint for servicing requests:</t>

	<t><list style="symbols"><t>socket()</t>

	<t>bind()</t>

	<t>listen()</t>

	<t>recvmsg()</t>

	<t>sendmsg()</t>

	<t>close()</t>

	</list>
	</t>

	<t>
   A typical client uses the following calls in sequence to set up an
   association with a server to request services:</t>

	<t><list style="symbols"><t>socket()</t>

	<t>sendmsg()</t>

	<t>recvmsg()</t>

	<t>close()</t>

	</list>
	</t>

	<t>
   In this style, by default, all of the associations connected to the
   endpoint are represented with a single socket.  Each association is
   assigned an association identifier (the type is sctp_assoc_t) so that
   an application can use it to differentiate among them.  In some
   implementations, the peer endpoints' addresses can also be used for
   this purpose.  But this is not required for performance reasons.  If
   an implementation does not support using addresses to differentiate
   between different associations, the sendto() call can only be used to
   set up an association implicitly.  It cannot be used to send data to
   an established association, as the association identifier cannot be
   specified.</t>

	<t>
   Once an association identifier is assigned to an SCTP association,
   that identifier will not be reused until the application explicitly
   terminates the use of the association.  The resources belonging to
   that association will not be freed until that happens.  This is
   similar to the close() operation on a normal socket.  The only
   exception is when the SCTP_AUTOCLOSE option (<xref target="section-8.1.8"/>) is set.
   In this case, after the association is terminated gracefully and
   automatically, the association identifier assigned to it can be
   reused.  All applications using this option should be aware of this
   to avoid the possible problem of sending data to an incorrect peer
   endpoint.</t>

	<t>
   If the server or client wishes to branch an existing association off
   to a separate socket, it is required to call sctp_peeloff() and to
   specify the association identifier.  The sctp_peeloff() call will
   return a new one-to-one style socket that can then be used with
   recv() and send() functions for message passing.  See <xref target="section-9.2"/> for
   more on branched-off associations.</t>

	<t>
   Once an association is branched off to a separate socket, it becomes
   completely separated from the original socket.  All subsequent
   control and data operations to that association must be done through
   the new socket.  For example, the close() operation on the original
   socket will not terminate any associations that have been branched
   off to a different socket.</t>

	<t>
   One-to-many style socket calls are discussed in more detail in the
   following subsections.</t>

	<section title="socket()" anchor="section-3.1.1"><t>
   Applications use socket() to create a socket descriptor to represent
   an SCTP endpoint.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="11"><t hangText="int socket(int domain,">
	<vspace blankLines="0"/>
	int type,
              int protocol);
	</t>

	</list>
	</t>

	<t>
   and one uses PF_INET or PF_INET6 as the domain, SOCK_SEQPACKET as the
   type, and IPPROTO_SCTP as the protocol.</t>

	<t>
   Here, SOCK_SEQPACKET indicates the creation of a one-to-many style
   socket.</t>

	<t>
   The function returns a socket descriptor, or -1 in case of an error.</t>

	<t>
   Using the PF_INET domain indicates the creation of an endpoint that
   can use only IPv4 addresses, while PF_INET6 creates an endpoint that
   can use both IPv6 and IPv4 addresses.</t>

	</section>

	<section title="bind()" anchor="section-3.1.2"><t>
   Applications use bind() to specify with which local address and port
   the SCTP endpoint should associate itself.</t>

	<t>
   An SCTP endpoint can be associated with multiple addresses.  To do
   this, sctp_bindx() is introduced in <xref target="section-9.1"/> to help applications
   do the job of associating multiple addresses.  But note that an
   endpoint can only be associated with one local port.</t>

	<t>
   These addresses associated with a socket are the eligible transport
   addresses for the endpoint to send and receive data.  The endpoint
   will also present these addresses to its peers during the association
   initialization process; see <xref target="RFC4960"/>.</t>

	<t>
   After calling bind(), if the endpoint wishes to accept new
   associations on the socket, it must call listen() (see
   <xref target="section-3.1.3"/>).</t>

	<t>
   The function prototype of bind() is</t>

	<t><list style="hanging" hangIndent="9"><t hangText="int bind(int sd,">
	<vspace blankLines="0"/>
	struct sockaddr *addr,
            socklen_t addrlen);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor returned by socket().
	<vspace blankLines="0"/>
	</t>

	<t hangText="addr:">
	The address structure (struct sockaddr_in for an IPv4 address
	<vspace blankLines="0"/>
	or struct sockaddr_in6 for an IPv6 address; see <xref target="RFC3493"/>).
	</t>

	<t hangText="addrlen:">
	The size of the address structure.
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<t>
   bind() returns 0 on success and -1 in case of an error.</t>

	<t>
   If sd is an IPv4 socket, the address passed must be an IPv4 address.
   If the sd is an IPv6 socket, the address passed can either be an IPv4
   or an IPv6 address.</t>

	<t>
   Applications cannot call bind() multiple times to associate multiple
   addresses to an endpoint.  After the first call to bind(), all
   subsequent calls will return an error.</t>

	<t>
   If the IP address part of addr is specified as a wildcard (INADDR_ANY
   for an IPv4 address, or as IN6ADDR_ANY_INIT or in6addr_any for an
   IPv6 address), the operating system will associate the endpoint with
   an optimal address set of the available interfaces.  If the IPv4
   sin_port or IPv6 sin6_port is set to 0, the operating system will
   choose an ephemeral port for the endpoint.</t>

	<t>
   If bind() is not called prior to a sendmsg() call that initiates a
   new association, the system picks an ephemeral port and will choose
   an address set equivalent to binding with a wildcard address.  One of
   those addresses will be the primary address for the association.
   This automatically enables the multi-homing capability of SCTP.</t>

	<t>
   The completion of this bind() process does not allow the SCTP
   endpoint to accept inbound SCTP association requests.  Until a
   listen() system call, described below, is performed on the socket,
   the SCTP endpoint will promptly reject an inbound SCTP INIT request
   with an SCTP ABORT.</t>

	</section>

	<section title="listen()" anchor="section-3.1.3"><t>
   By default, a one-to-many style socket does not accept new
   association requests.  An application uses listen() to mark a socket
   as being able to accept new associations.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="11"><t hangText="int listen(int sd,">
	<vspace blankLines="0"/>
	int backlog);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor of the endpoint.
	<vspace blankLines="0"/>
	</t>

	<t hangText="backlog:">
	If backlog is non-zero, enable listening, else disable
	<vspace blankLines="0"/>
	listening.
	</t>

	</list>
	</t>

	<t>
   listen() returns 0 on success and -1 in case of an error.</t>

	<t>
   Note that one-to-many style socket consumers do not need to call
   accept() to retrieve new associations.  Calling accept() on a one-to-
   many style socket should return EOPNOTSUPP.  Rather, new associations
   are accepted automatically, and notifications of the new associations
   are delivered via recvmsg() with the SCTP_ASSOC_CHANGE event (if
   these notifications are enabled).  Clients will typically not call
   listen(), so that they can be assured that only actively initiated
   associations are possible on the socket.  Server or peer-to-peer
   sockets, on the other hand, will always accept new associations, so a
   well-written application using server one-to-many style sockets must
   be prepared to handle new associations from unwanted peers.</t>

	<t>
   Also note that the SCTP_ASSOC_CHANGE event provides the association
   identifier for a new association, so if applications wish to use the
   association identifier as a parameter to other socket calls, they
   should ensure that the SCTP_ASSOC_CHANGE event is enabled.</t>

	</section>

	<section title="sendmsg() and recvmsg()" anchor="section-3.1.4"><t>
   An application uses the sendmsg() and recvmsg() calls to transmit
   data to and receive data from its peer.</t>

	<t>
   The function prototypes are</t>

	<t><list style="hanging" hangIndent="16"><t hangText="ssize_t sendmsg(int sd,">
	<vspace blankLines="0"/>
	const struct msghdr *message,
                   int flags);
	</t>

	</list>
	</t>

	<t>
   and</t>

	<t><list style="hanging" hangIndent="16"><t hangText="ssize_t recvmsg(int sd,">
	<vspace blankLines="0"/>
	struct msghdr *message,
                   int flags);
	</t>

	</list>
	</t>

	<t>
   using the following arguments:</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor of the endpoint.
	<vspace blankLines="0"/>
	</t>

	<t hangText="message:">
	Pointer to the msghdr structure that contains a single user
	<vspace blankLines="0"/>
	message and possibly some ancillary data.  See <xref target="section-5"/> for a
      complete description of the data structures.
	</t>

	<t hangText="flags:">
	No new flags are defined for SCTP at this level.  See
	<vspace blankLines="0"/>
	<xref target="section-5"/> for SCTP-specific flags used in the msghdr structure.
	</t>

	</list>
	</t>

	<t>
   sendmsg() returns the number of bytes accepted by the kernel or -1 in
   case of an error.  recvmsg() returns the number of bytes received or
   -1 in case of an error.</t>

	<t>
   As described in <xref target="section-5"/>, different types of ancillary data can be
   sent and received along with user data.  When sending, the ancillary
   data is used to specify the sent behavior, such as the SCTP stream
   number to use.  When receiving, the ancillary data is used to
   describe the received data, such as the SCTP stream sequence number
   of the message.</t>

	<t>
   When sending user data with sendmsg(), the msg_name field in the
   msghdr structure will be filled with one of the transport addresses
   of the intended receiver.  If there is no existing association
   between the sender and the intended receiver, the sender's SCTP stack
   will set up a new association and then send the user data (see
   <xref target="section-7.5"/> for more on implicit association setup).  If sendmsg() is
   called with no data and there is no existing association, a new one
   will be established.  The SCTP_INIT type ancillary data can be used
   to change some of the parameters used to set up a new association.
   If sendmsg() is called with NULL data, and there is no existing
   association but the SCTP_ABORT or SCTP_EOF flags are set as described
   in <xref target="section-5.3.4"/>, then -1 is returned and errno is set to EINVAL.
   Sending a message using sendmsg() is atomic unless explicit end of
   record (EOR) marking is enabled on the socket specified by sd (see
   <xref target="section-8.1.26"/>).</t>

	<t>
   If a peer sends a SHUTDOWN, an SCTP_SHUTDOWN_EVENT notification will
   be delivered if that notification has been enabled, and no more data
   can be sent to that association.  Any attempt to send more data will
   cause sendmsg() to return with an ESHUTDOWN error.  Note that the
   socket is still open for reading at this point, so it is possible to
   retrieve notifications.</t>

	<t>
   When receiving a user message with recvmsg(), the msg_name field in
   the msghdr structure will be populated with the source transport
   address of the user data.  The caller of recvmsg() can use this
   address information to determine to which association the received
   user message belongs.  Note that if SCTP_ASSOC_CHANGE events are
   disabled, applications must use the peer transport address provided
   in the msg_name field by recvmsg() to perform correlation to an
   association, since they will not have the association identifier.</t>

	<t>
   If all data in a single message has been delivered, MSG_EOR will be
   set in the msg_flags field of the msghdr structure (see <xref target="section-5.1"/>).</t>

	<t>
   If the application does not provide enough buffer space to completely
   receive a data message, MSG_EOR will not be set in msg_flags.
   Successive reads will consume more of the same message until the
   entire message has been delivered, and MSG_EOR will be set.</t>

	<t>
   If the SCTP stack is running low on buffers, it may partially deliver
   a message.  In this case, MSG_EOR will not be set, and more calls to
   recvmsg() will be necessary to completely consume the message.  Only
   one message at a time can be partially delivered in any stream.  The
   socket option SCTP_FRAGMENT_INTERLEAVE controls various aspects of
   what interlacing of messages occurs for both the one-to-one and the
   one-to-many style sockets.  Please consult <xref target="section-8.1.20"/> for further
   details on message delivery options.</t>

	</section>

	<section title="close()" anchor="section-3.1.5"><t>
   Applications use close() to perform graceful shutdown (as described
   in Section 10.1 of <xref target="RFC4960"/>) on all of the associations currently
   represented by a one-to-many style socket.</t>

	<t>
   The function prototype is</t>

	<t>
   int close(int sd);</t>

	<t>
   and the argument is</t>

	<t><list style="hanging" hangIndent="5"><t hangText="sd:">
	The socket descriptor of the associations to be closed.
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<t>
   0 is returned on success and -1 in case of an error.</t>

	<t>
   To gracefully shut down a specific association represented by the
   one-to-many style socket, an application should use the sendmsg()
   call and include the SCTP_EOF flag.  A user may optionally terminate
   an association non-gracefully by using sendmsg() with the SCTP_ABORT
   flag set and possibly passing a user-specified abort code in the data
   field.  Both flags SCTP_EOF and SCTP_ABORT are passed with ancillary
   data (see <xref target="section-5.3.4"/>) in the sendmsg() call.</t>

	<t>
   If sd in the close() call is a branched-off socket representing only
   one association, the shutdown is performed on that association only.</t>

	</section>

	<section title="connect()" anchor="section-3.1.6"><t>
   An application may use the connect() call in the one-to-many style to
   initiate an association without sending data.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="12"><t hangText="int connect(int sd,">
	<vspace blankLines="0"/>
	const struct sockaddr *nam,
               socklen_t len);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor to which a new association is added.
	<vspace blankLines="0"/>
	</t>

	<t hangText="nam:">
	The address structure (struct sockaddr_in for an IPv4 address
	<vspace blankLines="0"/>
	or struct sockaddr_in6 for an IPv6 address; see <xref target="RFC3493"/>).
	</t>

	<t hangText="len:">
	The size of the address.
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<t>
   0 is returned on success and -1 in case of an error.</t>

	<t>
   Multiple connect() calls can be made on the same socket to create
   multiple associations.  This is different from the semantics of
   connect() on a UDP socket.</t>

	<t>
   Note that SCTP allows data exchange, similar to T/TCP <xref target="RFC1644"/> (made
   Historic by <xref target="RFC6247"/>), during the association setup phase.  If an
   application wants to do this, it cannot use the connect() call.
   Instead, it should use sendto() or sendmsg() to initiate an
   association.  If it uses sendto() and it wants to change the
   initialization behavior, it needs to use the SCTP_INITMSG socket
   option before calling sendto().  Or it can use sendmsg() with
   SCTP_INIT type ancillary data to initiate an association without
   calling setsockopt().  Note that the implicit setup is supported for
   the one-to-many style sockets.</t>

	<t>
   SCTP does not support half close semantics.  This means that unlike
   T/TCP, MSG_EOF should not be set in the flags parameter when calling
   sendto() or sendmsg() when the call is used to initiate a connection.
   MSG_EOF is not an acceptable flag with an SCTP socket.</t>

	</section>

	</section>

	<section title="Non-Blocking Mode" anchor="section-3.2"><t>
   Some SCTP applications may wish to avoid being blocked when calling a
   socket interface function.</t>

	<t>
   Once a bind() call and/or subsequent sctp_bindx() calls are complete
   on a one-to-many style socket, an application may set the
   non-blocking option via a fcntl() (such as O_NONBLOCK).  After
   setting the socket to non-blocking mode, the sendmsg() function
   returns immediately.  The success or failure of sending the data
   message (with possible SCTP_INITMSG ancillary data) will be signaled
   by the SCTP_ASSOC_CHANGE event with SCTP_COMM_UP or
   SCTP_CANT_START_ASSOC.  If user data could not be sent (due to an
   SCTP_CANT_START_ASSOC), the sender will also receive an
   SCTP_SEND_FAILED_EVENT event.  Events can be received by the user
   calling recvmsg().  A server (having called listen()) is also
   notified of an association-up event via the reception of an
   SCTP_ASSOC_CHANGE with SCTP_COMM_UP via the calling of recvmsg() and
   possibly the reception of the first data message.</t>

	<t>
   To shut down the association gracefully, the user must call sendmsg()
   with no data and with the SCTP_EOF flag set as described in
   <xref target="section-5.3.4"/>.  The function returns immediately, and completion of
   the graceful shutdown is indicated by an SCTP_ASSOC_CHANGE
   notification of type SCTP_SHUTDOWN_COMP (see <xref target="section-6.1.1"/>).  Note
   that this can also be done using the sctp_sendv() call described in
   <xref target="section-9.12"/>.</t>

	<t>
   It is recommended that an application use caution when using select()
   (or poll()) for writing on a one-to-many style socket, because the
   interpretation of select() on write is implementation specific.
   Generally, a positive return on a select() on write would only
   indicate that one of the associations represented by the one-to-many
   style socket is writable.  An application that writes after the
   select() returns may still block, since the association that was
   writable is not the destination association of the write call.
   Likewise, select() (or poll()) for reading from a one-to-many style
   socket will only return an indication that one of the associations
   represented by the socket has data to be read.</t>

	<t>
   An application that wishes to know that a particular association is
   ready for reading or writing should either use the one-to-one style
   or use the sctp_peeloff() function (see <xref target="section-9.2"/>) to separate the
   association of interest from the one-to-many style socket.</t>

	<t>
   Note that some implementations may have an extended select call, such
   as epoll or kqueue, that may escape this limitation and allow a
   select on a specific association of a one-to-many style socket, but
   this is an implementation-specific detail that a portable application
   cannot depend on.</t>

	</section>

	<section title="Special Considerations" anchor="section-3.3"><t>
   The fact that a one-to-many style socket can provide access to many
   SCTP associations through a single socket descriptor has important
   implications for both application programmers and system programmers
   implementing this API.  A key issue is how buffer space inside the
   sockets layer is managed.  Because this implementation detail
   directly affects how application programmers must write their code to
   ensure correct operation and portability, this section provides some
   guidance to both implementers and application programmers.</t>

	<t>
   An important feature that SCTP shares with TCP is flow control.
   Specifically, a sender may not send data faster than the receiver can
   consume it.</t>

	<t>
   For TCP, flow control is typically provided for in the sockets API as
   follows.  If the reader stops reading, the sender queues messages in
   the socket layer until the send socket buffer is completely filled.
   This results in a "stalled connection".  Further attempts to write to
   the socket will block or return the error EAGAIN or EWOULDBLOCK for a
   non-blocking socket.  At some point, either the connection is closed,
   or the receiver begins to read, again freeing space in the output
   queue.</t>

	<t>
   For one-to-one style SCTP sockets (this includes sockets descriptors
   that were separated from a one-to-many style socket with
   sctp_peeloff()), the behavior is identical.  For one-to-many style
   SCTP sockets, there are multiple associations for a single socket,
   which makes the situation more complicated.  If the implementation
   uses a single buffer space allocation shared by all associations, a
   single stalled association can prevent the further sending of data on
   all associations active on a particular one-to-many style socket.</t>

	<t>
   For a blocking socket, it should be clear that a single stalled
   association can block the entire socket.  For this reason,
   application programmers may want to use non-blocking one-to-many
   style sockets.  The application should at least be able to send
   messages to the non-stalled associations.</t>

	<t>
   But a non-blocking socket is not sufficient if the API implementer
   has chosen a single shared buffer allocation for the socket.  A
   single stalled association would eventually cause the shared
   allocation to fill, and it would become impossible to send even to
   non-stalled associations.</t>

	<t>
   The API implementer can solve this problem by providing each
   association with its own allocation of outbound buffer space.  Each
   association should conceptually have as much buffer space as it would
   have if it had its own socket.  As a bonus, this simplifies the
   implementation of sctp_peeloff().</t>

	<t>
   To ensure that a given stalled association will not prevent other
   non-stalled associations from being writable, application programmers
   should either</t>

	<t><list style="symbols"><t>demand that the underlying implementation dedicates independent
      buffer space reservation to each association (as suggested
      above), or</t>

	<t>verify that their application-layer protocol does not permit large
      amounts of unread data at the receiver (this is true of some
      request-response protocols, for example), or</t>

	<t>use one-to-one style sockets for association, which may
      potentially stall (either from the beginning, or by using
      sctp_peeloff() before sending large amounts of data that may cause
      a stalled condition).</t>

	</list>
	</t>

	</section>

	</section>

	<section title="One-to-One Style Interface" anchor="section-4"><t>
   The goal of this style is to follow as closely as possible the
   current practice of using the sockets interface for a connection-
   oriented protocol such as TCP.  This style enables existing
   applications using connection-oriented protocols to be ported to SCTP
   with very little effort.</t>

	<t>
   One-to-one style sockets can be connected (explicitly or implicitly)
   at most once, similar to TCP sockets.</t>

	<t>
   Note that some new SCTP features and some new SCTP socket options can
   only be utilized through the use of sendmsg() and recvmsg() calls;
   see <xref target="section-4.1.8"/>.</t>

	<section title="Basic Operation" anchor="section-4.1"><t>
   A typical one-to-one style server uses the following system call
   sequence to prepare an SCTP endpoint for servicing requests:</t>

	<t><list style="symbols"><t>socket()</t>

	<t>bind()</t>

	<t>listen()</t>

	<t>accept()</t>

	</list>
	</t>

	<t>
   The accept() call blocks until a new association is set up.  It
   returns with a new socket descriptor.  The server then uses the new
   socket descriptor to communicate with the client, using recv() and
   send() calls to get requests and send back responses.</t>

	<t>
   Then it calls</t>

	<t><list style="symbols"><t>close()</t>

	</list>
	</t>

	<t>
   to terminate the association.</t>

	<t>
   A typical client uses the following system call sequence to set up an
   association with a server to request services:</t>

	<t><list style="symbols"><t>socket()</t>

	<t>connect()</t>

	</list>
	</t>

	<t>
   After returning from the connect() call, the client uses send()/
   sendmsg() and recv()/recvmsg() calls to send out requests and receive
   responses from the server.</t>

	<t>
   The client calls</t>

	<t><list style="symbols"><t>close()</t>

	</list>
	</t>

	<t>
   to terminate this association when done.</t>

	<section title="socket()" anchor="section-4.1.1"><t>
   Applications call socket() to create a socket descriptor to represent
   an SCTP endpoint.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="11"><t hangText="int socket(int domain,">
	<vspace blankLines="0"/>
	int type,
              int protocol);
	</t>

	</list>
	</t>

	<t>
   and one uses PF_INET or PF_INET6 as the domain, SOCK_STREAM as the
   type, and IPPROTO_SCTP as the protocol.</t>

	<t>
   Here, SOCK_STREAM indicates the creation of a one-to-one style
   socket.</t>

	<t>
   Using the PF_INET domain indicates the creation of an endpoint that
   can use only IPv4 addresses, while PF_INET6 creates an endpoint that
   can use both IPv6 and IPv4 addresses.</t>

	</section>

	<section title="bind()" anchor="section-4.1.2"><t>
   Applications use bind() to specify with which local address and port
   the SCTP endpoint should associate itself.</t>

	<t>
   An SCTP endpoint can be associated with multiple addresses.  To do
   this, sctp_bindx() is introduced in <xref target="section-9.1"/> to help applications
   do the job of associating multiple addresses.  But note that an
   endpoint can only be associated with one local port.</t>

	<t>
   These addresses associated with a socket are the eligible transport
   addresses for the endpoint to send and receive data.  The endpoint
   will also present these addresses to its peers during the association
   initialization process; see <xref target="RFC4960"/>.</t>

	<t>
   The function prototype of bind() is</t>

	<t><list style="hanging" hangIndent="9"><t hangText="int bind(int sd,">
	<vspace blankLines="0"/>
	struct sockaddr *addr,
            socklen_t addrlen);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor returned by socket().
	<vspace blankLines="0"/>
	</t>

	<t hangText="addr:">
	The address structure (struct sockaddr_in for an IPv4 address
	<vspace blankLines="0"/>
	or struct sockaddr_in6 for an IPv6 address; see <xref target="RFC3493"/>).
	</t>

	<t hangText="addrlen:">
	The size of the address structure.
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<t>
   If sd is an IPv4 socket, the address passed must be an IPv4 address.
   If sd is an IPv6 socket, the address passed can either be an IPv4 or
   an IPv6 address.</t>

	<t>
   Applications cannot call bind() multiple times to associate multiple
   addresses to the endpoint.  After the first call to bind(), all
   subsequent calls will return an error.</t>

	<t>
   If the IP address part of addr is specified as a wildcard (INADDR_ANY
   for an IPv4 address, or as IN6ADDR_ANY_INIT or in6addr_any for an
   IPv6 address), the operating system will associate the endpoint with
   an optimal address set of the available interfaces.  If the IPv4
   sin_port or IPv6 sin6_port is set to 0, the operating system will
   choose an ephemeral port for the endpoint.</t>

	<t>
   If bind() is not called prior to the connect() call, the system picks
   an ephemeral port and will choose an address set equivalent to
   binding with a wildcard address.  One of these addresses will be the
   primary address for the association.  This automatically enables the
   multi-homing capability of SCTP.</t>

	<t>
   The completion of this bind() process does not allow the SCTP
   endpoint to accept inbound SCTP association requests.  Until a
   listen() system call, described below, is performed on the socket,
   the SCTP endpoint will promptly reject an inbound SCTP INIT request
   with an SCTP ABORT.</t>

	</section>

	<section title="listen()" anchor="section-4.1.3"><t>
   Applications use listen() to allow the SCTP endpoint to accept
   inbound associations.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="11"><t hangText="int listen(int sd,">
	<vspace blankLines="0"/>
	int backlog);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor of the SCTP endpoint.
	<vspace blankLines="0"/>
	</t>

	<t hangText="backlog:">
	Specifies the max number of outstanding associations
	<vspace blankLines="0"/>
	allowed in the socket's accept queue.  These are the associations
      that have finished the four-way initiation handshake (see
      Section 5 of <xref target="RFC4960"/>) and are in the ESTABLISHED state.  Note
      that a backlog of '0' indicates that the caller no longer wishes
      to receive new associations.
	</t>

	</list>
	</t>

	<t>
   listen() returns 0 on success and -1 in case of an error.</t>

	</section>

	<section title="accept()" anchor="section-4.1.4"><t>
   Applications use the accept() call to remove an established SCTP
   association from the accept queue of the endpoint.  A new socket
   descriptor will be returned from accept() to represent the newly
   formed association.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="11"><t hangText="int accept(int sd,">
	<vspace blankLines="0"/>
	struct sockaddr *addr,
              socklen_t *addrlen);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The listening socket descriptor.
	<vspace blankLines="0"/>
	</t>

	<t hangText="addr:">
	On return, addr (struct sockaddr_in for an IPv4 address or
	<vspace blankLines="0"/>
	struct sockaddr_in6 for an IPv6 address; see <xref target="RFC3493"/>) will
      contain the primary address of the peer endpoint.
	</t>

	<t hangText="addrlen:">
	On return, addrlen will contain the size of addr.
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<t>
   The function returns the socket descriptor for the newly formed
   association on success and -1 in case of an error.</t>

	</section>

	<section title="connect()" anchor="section-4.1.5"><t>
   Applications use connect() to initiate an association to a peer.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="12"><t hangText="int connect(int sd,">
	<vspace blankLines="0"/>
	const struct sockaddr *addr,
               socklen_t addrlen);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor of the endpoint.
	<vspace blankLines="0"/>
	</t>

	<t hangText="addr:">
	The peer's (struct sockaddr_in for an IPv4 address or struct
	<vspace blankLines="0"/>
	sockaddr_in6 for an IPv6 address; see <xref target="RFC3493"/>) address.
	</t>

	<t hangText="addrlen:">
	The size of the address.
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<t>
   connect() returns 0 on success and -1 on error.</t>

	<t>
   This operation corresponds to the ASSOCIATE primitive described in
   Section 10.1 of <xref target="RFC4960"/>.</t>

	<t>
   The number of outbound streams the new association has is stack
   dependent.  Before connecting, applications can use the SCTP_INITMSG
   option described in <xref target="section-8.1.3"/> to change the number of outbound
   streams.</t>

	<t>
   If bind() is not called prior to the connect() call, the system picks
   an ephemeral port and will choose an address set equivalent to
   binding with INADDR_ANY and IN6ADDR_ANY_INIT for IPv4 and IPv6
   sockets, respectively.  One of the addresses will be the primary
   address for the association.  This automatically enables the
   multi-homing capability of SCTP.</t>

	<t>
   Note that SCTP allows data exchange, similar to T/TCP <xref target="RFC1644"/> (made
   Historic by <xref target="RFC6247"/>), during the association setup phase.  If an
   application wants to do this, it cannot use the connect() call.
   Instead, it should use sendto() or sendmsg() to initiate an
   association.  If it uses sendto() and it wants to change the
   initialization behavior, it needs to use the SCTP_INITMSG socket
   option before calling sendto().  Or it can use sendmsg() with
   SCTP_INIT type ancillary data to initiate an association without
   calling setsockopt().  Note that the implicit setup is supported for
   the one-to-one style sockets.</t>

	<t>
   SCTP does not support half close semantics.  This means that unlike
   T/TCP, MSG_EOF should not be set in the flags parameter when calling
   sendto() or sendmsg() when the call is used to initiate a connection.
   MSG_EOF is not an acceptable flag with an SCTP socket.</t>

	</section>

	<section title="close()" anchor="section-4.1.6"><t>
   Applications use close() to gracefully close down an association.</t>

	<t>
   The function prototype is</t>

	<t>
   int close(int sd);</t>

	<t>
   and the argument is</t>

	<t><list style="hanging" hangIndent="5"><t hangText="sd:">
	The socket descriptor of the association to be closed.
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<t>
   close() returns 0 on success and -1 in case of an error.</t>

	<t>
   After an application calls close() on a socket descriptor, no further
   socket operations will succeed on that descriptor.</t>

	</section>

	<section title="shutdown()" anchor="section-4.1.7"><t>
   SCTP differs from TCP in that it does not have half close semantics.
   Hence, the shutdown() call for SCTP is an approximation of the TCP
   shutdown() call, and solves some different problems.  Full TCP
   compatibility is not provided, so developers porting TCP applications
   to SCTP may need to recode sections that use shutdown().  (Note that
   it is possible to achieve the same results as half close in SCTP
   using SCTP streams.)</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="13"><t hangText="int shutdown(int sd,">
	<vspace blankLines="0"/>
	int how);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor of the association to be closed.
	<vspace blankLines="0"/>
	</t>

	<t hangText="how:">
	Specifies the type of shutdown.  The values are as follows:
	<vspace blankLines="1"/>
	SHUT_RD:  Disables further receive operations.  No SCTP protocol
         action is taken.
	<list style="hanging" hangIndent="3"><t hangText="SHUT_WR:">
	Disables further send operations, and initiates the SCTP
	<vspace blankLines="0"/>
	shutdown sequence.
	</t>

	<t hangText="SHUT_RDWR:">
	Disables further send and receive operations, and
	<vspace blankLines="0"/>
	initiates the SCTP shutdown sequence.
	</t>

	</list>
	</t>

	</list>
	</t>

	<t>
   shutdown() returns 0 on success and -1 in case of an error.</t>

	<t>
   The major difference between SCTP and TCP shutdown() is that SCTP
   SHUT_WR initiates immediate and full protocol shutdown, whereas TCP
   SHUT_WR causes TCP to go into the half close state.  SHUT_RD behaves
   the same for SCTP as for TCP.  The purpose of SCTP SHUT_WR is to
   close the SCTP association while still leaving the socket descriptor
   open.  This allows the caller to receive back any data that SCTP is
   unable to deliver (see <xref target="section-6.1.4"/> for more information) and
   receive event notifications.</t>

	<t>
   To perform the ABORT operation described in Section 10.1 of
   <xref target="RFC4960"/>, an application can use the socket option SO_LINGER.
   SO_LINGER is described in <xref target="section-8.1.4"/>.</t>

	</section>

	<section title="sendmsg() and recvmsg()" anchor="section-4.1.8"><t>
   With a one-to-one style socket, the application can also use
   sendmsg() and recvmsg() to transmit data to and receive data from its
   peer.  The semantics is similar to those used in the one-to-many
   style (see <xref target="section-3.1.4"/>), with the following differences:</t>

	<t><list style="numbers"><t>When sending, the msg_name field in the msghdr is not used to
       specify the intended receiver; rather, it is used to indicate a
       preferred peer address if the sender wishes to discourage the
       stack from sending the message to the primary address of the
       receiver.  If the socket is connected and the transport address
       given is not part of the current association, the data will not
       be sent, and an SCTP_SEND_FAILED_EVENT event will be delivered to
       the application if send failure events are enabled.</t>

	<t>Using sendmsg() on a non-connected one-to-one style socket for
       implicit connection setup may or may not work, depending on the
       SCTP implementation.</t>

	</list>
	</t>

	</section>

	<section title="getpeername()" anchor="section-4.1.9"><t>
   Applications use getpeername() to retrieve the primary socket address
   of the peer.  This call is for TCP compatibility and is not
   multi-homed.  It may not work with one-to-many style sockets,
   depending on the implementation.  See <xref target="section-9.3"/> for a multi-homed
   style version of the call.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="16"><t hangText="int getpeername(int sd,">
	<vspace blankLines="0"/>
	struct sockaddr *address,
                   socklen_t *len);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor to be queried.
	<vspace blankLines="0"/>
	</t>

	<t hangText="address:">
	On return, the peer primary address is stored in this
	<vspace blankLines="0"/>
	buffer.  If the socket is an IPv4 socket, the address will be
      IPv4.  If the socket is an IPv6 socket, the address will be either
      an IPv6 or IPv4 address.
	</t>

	<t hangText="len:">
	The caller should set the length of address here.  On return,
	<vspace blankLines="0"/>
	this is set to the length of the returned address.
	</t>

	</list>
	</t>

	<t>
   getpeername() returns 0 on success and -1 in case of an error.</t>

	<t>
   If the actual length of the address is greater than the length of the
   supplied sockaddr structure, the stored address will be truncated.</t>

	</section>

	</section>

	</section>

	<section title="Data Structures" anchor="section-5"><t>
   This section discusses important data structures that are specific to
   SCTP and are used with sendmsg() and recvmsg() calls to control SCTP
   endpoint operations and to access ancillary information and
   notifications.</t>

	<section title="The msghdr and cmsghdr Structures" anchor="section-5.1"><t>
   The msghdr structure used in the sendmsg() and recvmsg() calls, as
   well as the ancillary data carried in the structure, is the key for
   the application to set and get various control information from the
   SCTP endpoint.</t>

	<t>
   The msghdr and the related cmsghdr structures are defined and
   discussed in detail in <xref target="RFC3542"/>.  They are defined as</t>

	<figure><artwork><![CDATA[
struct msghdr {
  void *msg_name;           /* ptr to socket address structure */
  socklen_t msg_namelen;    /* size of socket address structure */
  struct iovec *msg_iov;    /* scatter/gather array */
  int msg_iovlen;           /* # elements in msg_iov */
  void *msg_control;        /* ancillary data */
  socklen_t msg_controllen; /* ancillary data buffer length */
  int msg_flags;            /* flags on received message */
};

struct cmsghdr {
  socklen_t cmsg_len; /* # bytes, including this header */
  int cmsg_level;     /* originating protocol */
  int cmsg_type;      /* protocol-specific type */
                      /* followed by unsigned char cmsg_data[]; */
};
]]></artwork>
	</figure>
	<t>
   In the msghdr structure, the usage of msg_name has been discussed in
   previous sections (see Sections 3.1.4 and 4.1.8).</t>

	<t>
   The scatter/gather buffers, or I/O vectors (pointed to by the msg_iov
   field) are treated by SCTP as a single user message for both
   sendmsg() and recvmsg().</t>

	<t>
   The SCTP stack uses the ancillary data (msg_control field) to
   communicate the attributes, such as SCTP_RCVINFO, of the message
   stored in msg_iov to the socket endpoint.  The different ancillary
   data types are described in <xref target="section-5.3"/>.</t>

	<t>
   The msg_flags are not used when sending a message with sendmsg().</t>

	<t>
   If a notification has arrived, recvmsg() will return the notification
   in the msg_iov field and set the MSG_NOTIFICATION flag in msg_flags.
   If the MSG_NOTIFICATION flag is not set, recvmsg() will return data.
   See <xref target="section-6"/> for more information about notifications.</t>

	<t>
   If all portions of a data frame or notification have been read,
   recvmsg() will return with MSG_EOR set in msg_flags.</t>

	</section>

	<section title="Ancillary Data Considerations and Semantics" anchor="section-5.2"><t>
   Programming with ancillary socket data (msg_control) contains some
   subtleties and pitfalls, which are discussed below.</t>

	<section title="Multiple Items and Ordering" anchor="section-5.2.1"><t>
   Multiple ancillary data items may be included in any call to
   sendmsg() or recvmsg(); these may include multiple SCTP items,
   non-SCTP items (such as IP-level items), or both.</t>

	<t>
   The ordering of ancillary data items (either by SCTP or another
   protocol) is not significant and is implementation dependent, so
   applications must not depend on any ordering.</t>

	<t>
   SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO type ancillary data always
   corresponds to the data in the msghdr's msg_iov member.  There can be
   only one such type of ancillary data for each sendmsg() or recvmsg()
   call.</t>

	</section>

	<section title="Accessing and Manipulating Ancillary Data" anchor="section-5.2.2"><t>
   Applications can infer the presence of data or ancillary data by
   examining the msg_iovlen and msg_controllen msghdr members,
   respectively.</t>

	<t>
   Implementations may have different padding requirements for ancillary
   data, so portable applications should make use of the macros
   CMSG_FIRSTHDR, CMSG_NXTHDR, CMSG_DATA, CMSG_SPACE, and CMSG_LEN.  See
   <xref target="RFC3542"/> and the SCTP implementation's documentation for more
   information.  The following is an example, from <xref target="RFC3542"/>,
   demonstrating the use of these macros to access ancillary data:</t>

	<figure><artwork><![CDATA[
struct msghdr msg;
struct cmsghdr *cmsgptr;

/* fill in msg */

/* call recvmsg() */

for (cmsgptr = CMSG_FIRSTHDR(&msg); cmsgptr != NULL;
     cmsgptr = CMSG_NXTHDR(&msg, cmsgptr)) {
  if (cmsgptr->cmsg_len == 0) {
     /* Error handling */
     break;
  }
  if (cmsgptr->cmsg_level == ... && cmsgptr->cmsg_type == ... ) {
    u_char  *ptr;

    ptr = CMSG_DATA(cmsgptr);
    /* process data pointed to by ptr */
  }
}
]]></artwork>
	</figure>
	</section>

	<section title="Control Message Buffer Sizing" anchor="section-5.2.3"><t>
   The information conveyed via SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO
   ancillary data will often be fundamental to the correct and sane
   operation of the sockets application.  This is particularly true for
   one-to-many style sockets, but also for one-to-one style sockets.
   For example, if an application needs to send and receive data on
   different SCTP streams, SCTP_SNDRCV/SCTP_SNDINFO/SCTP_RCVINFO
   ancillary data is indispensable.</t>

	<t>
   Given that some ancillary data is critical, and that multiple
   ancillary data items may appear in any order, applications should be
   carefully written to always provide a large enough buffer to contain
   all possible ancillary data that can be presented by recvmsg().  If
   the buffer is too small, and crucial data is truncated, it may pose a
   fatal error condition.</t>

	<t>
   Thus, it is essential that applications be able to deterministically
   calculate the maximum required buffer size to pass to recvmsg().  One
   constraint imposed on this specification that makes this possible is
   that all ancillary data definitions are of a fixed length.  One way
   to calculate the maximum required buffer size might be to take the
   sum of the sizes of all enabled ancillary data item structures, as
   calculated by CMSG_SPACE.  For example, if we enabled
   SCTP_SNDRCV_INFO and IPV6_RECVPKTINFO <xref target="RFC3542"/>, we would calculate
   and allocate the buffer size as follows:</t>

	<figure><artwork><![CDATA[
size_t total;
void *buf;

total = CMSG_SPACE(sizeof(struct sctp_sndrcvinfo)) +
        CMSG_SPACE(sizeof(struct in6_pktinfo));

buf = malloc(total);
]]></artwork>
	</figure>
	<t>
   We could then use this buffer (buf) for msg_control on each call to
   recvmsg() and be assured that we would not lose any ancillary data to
   truncation.</t>

	</section>

	</section>

	<section title="SCTP msg_control Structures" anchor="section-5.3"><t>
   A key element of all SCTP-specific socket extensions is the use of
   ancillary data to specify and access SCTP-specific data via the
   msghdr structure's msg_control member used in sendmsg() and
   recvmsg().  Fine-grained control over initialization and sending
   parameters are handled with ancillary data.</t>

	<t>
   Each ancillary data item is preceded by a struct cmsghdr (see
   <xref target="section-5.1"/>), which defines the function and purpose of the data
   contained in the cmsg_data[] member.</t>

	<t>
   By default, on either style of socket, SCTP will pass no ancillary
   data.  Specific ancillary data items can be enabled with socket
   options defined for SCTP; see <xref target="section-6.2"/>.</t>

	<t>
   Note that all ancillary types are of fixed length; see <xref target="section-5.2"/>
   for further discussion on this.  These data structures use struct
   sockaddr_storage (defined in <xref target="RFC3493"/>) as a portable, fixed-length
   address format.</t>

	<t>
   Other protocols may also provide ancillary data to the socket layer
   consumer.  These ancillary data items from other protocols may
   intermingle with SCTP data.  For example, the IPv6 sockets API
   definitions (<xref target="RFC3542"/> and <xref target="RFC3493"/>) define a number of ancillary
   data items.  If a sockets API consumer enables delivery of both SCTP
   and IPv6 ancillary data, they both may appear in the same msg_control
   buffer in any order.  An application may thus need to handle other
   types of ancillary data besides those passed by SCTP.</t>

	<t>
   The sockets application must provide a buffer large enough to
   accommodate all ancillary data provided via recvmsg().  If the buffer
   is not large enough, the ancillary data will be truncated and the
   msghdr's msg_flags will include MSG_CTRUNC.</t>

	<section title="SCTP Initiation Structure (SCTP_INIT)" anchor="section-5.3.1"><t>
   This cmsghdr structure provides information for initializing new SCTP
   associations with sendmsg().  The SCTP_INITMSG socket option uses
   this same data structure.  This structure is not used for recvmsg().</t>

	<texttable style="full"><ttcol> cmsg_level</ttcol>
	<ttcol> cmsg_type</ttcol>
	<ttcol> cmsg_data[]</ttcol>
	<c>IPPROTO_SCTP</c>
	<c>SCTP_INIT</c>
	<c>struct sctp_initmsg</c>
	<postamble>   The sctp_initmsg structure is defined below:</postamble>
	</texttable>
	<figure><artwork><![CDATA[
struct sctp_initmsg {
  uint16_t sinit_num_ostreams;
  uint16_t sinit_max_instreams;
  uint16_t sinit_max_attempts;
  uint16_t sinit_max_init_timeo;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="sinit_num_ostreams:">
	This is an integer representing the number of
	<vspace blankLines="0"/>
	streams to which the application wishes to be able to send.  This
      number is confirmed in the SCTP_COMM_UP notification and must be
      verified, since it is a negotiated number with the remote
      endpoint.  The default value of 0 indicates the use of the
      endpoint's default value.
	</t>

	<t hangText="sinit_max_instreams:">
	This value represents the maximum number of
	<vspace blankLines="0"/>
	inbound streams the application is prepared to support.  This
      value is bounded by the actual implementation.  In other words,
      the user may be able to support more streams than the operating
      system.  In such a case, the operating-system limit overrides the
      value requested by the user.  The default value of 0 indicates the
      use of the endpoint's default value.
	</t>

	<t hangText="sinit_max_attempts:">
	This integer specifies how many attempts the
	<vspace blankLines="0"/>
	SCTP endpoint should make at resending the INIT.  This value
      overrides the system SCTP 'Max.Init.Retransmits' value.  The
      default value of 0 indicates the use of the endpoint's default
      value.  This is normally set to the system's default
      'Max.Init.Retransmit' value.
	</t>

	<t hangText="sinit_max_init_timeo:">
	This value represents the largest timeout or
	<vspace blankLines="0"/>
	retransmission timeout (RTO) value (in milliseconds) to use in
      attempting an INIT.  Normally, the 'RTO.Max' is used to limit the
      doubling of the RTO upon timeout.  For the INIT message, this
      value may override 'RTO.Max'.  This value must not influence
      'RTO.Max' during data transmission and is only used to bound the
      initial setup time.  A default value of 0 indicates the use of the
      endpoint's default value.  This is normally set to the system's
      'RTO.Max' value (60 seconds).
	</t>

	</list>
	</t>

	</section>

	<section title="SCTP Header Information Structure (SCTP_SNDRCV) - DEPRECATED" anchor="section-5.3.2"><t>
   This cmsghdr structure specifies SCTP options for sendmsg() and
   describes SCTP header information about a received message through
   recvmsg().  This structure mixes the send and receive path.
   SCTP_SNDINFO (described in <xref target="section-5.3.4"/>) and SCTP_RCVINFO (described
   in <xref target="section-5.3.5"/>) split this information.  These structures should be
   used, when possible, since SCTP_SNDRCV is deprecated.</t>

	<texttable style="full"><ttcol> cmsg_level</ttcol>
	<ttcol> cmsg_type</ttcol>
	<ttcol> cmsg_data[]</ttcol>
	<c>IPPROTO_SCTP</c>
	<c>SCTP_SNDRCV</c>
	<c>struct sctp_sndrcvinfo</c>
	<postamble>   The sctp_sndrcvinfo structure is defined below:</postamble>
	</texttable>
	<figure><artwork><![CDATA[
struct sctp_sndrcvinfo {
  uint16_t sinfo_stream;
  uint16_t sinfo_ssn;
  uint16_t sinfo_flags;
  uint32_t sinfo_ppid;
  uint32_t sinfo_context;
  uint32_t sinfo_timetolive;
  uint32_t sinfo_tsn;
  uint32_t sinfo_cumtsn;
  sctp_assoc_t sinfo_assoc_id;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="sinfo_stream:">
	For recvmsg(), the SCTP stack places the message's
	<vspace blankLines="0"/>
	stream number in this value.  For sendmsg(), this value holds the
      stream number to which the application wishes to send this
      message.  If a sender specifies an invalid stream number, an error
      indication is returned and the call fails.
	</t>

	<t hangText="sinfo_ssn:">
	For recvmsg(), this value contains the stream sequence
	<vspace blankLines="0"/>
	number that the remote endpoint placed in the DATA chunk.  For
      fragmented messages, this is the same number for all deliveries of
      the message (if more than one recvmsg() is needed to read the
      message).  The sendmsg() call will ignore this parameter.
	</t>

	<t hangText="sinfo_flags:">
	This field may contain any of the following flags and
	<vspace blankLines="0"/>
	is composed of a bitwise OR of these values.
	<list style="hanging" hangIndent="3"><t hangText="recvmsg() flags:">
	<vspace blankLines="1"/>
	SCTP_UNORDERED:  This flag is present when the message was sent
            unordered.
	</t>

	<t hangText="sendmsg() flags:">
	<vspace blankLines="1"/>
	SCTP_UNORDERED:  This flag requests the unordered delivery of
            the message.  If this flag is clear, the datagram is
            considered an ordered send.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_ADDR_OVER:">
	This flag, for a one-to-many style socket,
	<vspace blankLines="0"/>
	requests that the SCTP stack override the primary
            destination address with the address found with the sendto/
            sendmsg call.
	</t>

	<t hangText="SCTP_ABORT:">
	Setting this flag causes the specified association
	<vspace blankLines="0"/>
	to abort by sending an ABORT message to the peer.  The ABORT
            chunk will contain an error cause of 'User Initiated Abort'
            with cause code 12.  The cause-specific information of this
            error cause is provided in msg_iov.
	</t>

	<t hangText="SCTP_EOF:">
	Setting this flag invokes the SCTP graceful shutdown
	<vspace blankLines="0"/>
	procedure on the specified association.  Graceful shutdown
            assures that all data queued by both endpoints is
            successfully transmitted before closing the association.
	</t>

	<t hangText="SCTP_SENDALL:">
	This flag, if set, will cause a one-to-many
	<vspace blankLines="0"/>
	style socket to send the message to all associations that
            are currently established on this socket.  For the one-to-
            one style socket, this flag has no effect.
	</t>

	</list>
	</t>

	</list>
	</t>

	<t hangText="sinfo_ppid:">
	This value in sendmsg() is an unsigned integer that is
	<vspace blankLines="0"/>
	passed to the remote end in each user message.  In recvmsg(), this
      value is the same information that was passed by the upper layer
      in the peer application.  Please note that the SCTP stack performs
      no byte order modification of this field.  For example, if the
      DATA chunk has to contain a given value in network byte order, the
      SCTP user has to perform the htonl() computation.
	</t>

	<t hangText="sinfo_context:">
	This value is an opaque 32-bit context datum that is
	<vspace blankLines="0"/>
	used in the sendmsg() function.  This value is passed back to the
      upper layer if an error occurs on the send of a message and is
      retrieved with each undelivered message.
	</t>

	<t hangText="sinfo_timetolive:">
	For the sending side, this field contains the
	<vspace blankLines="0"/>
	message's time to live, in milliseconds.  The sending side will
      expire the message within the specified time period if the message
      has not been sent to the peer within this time period.  This value
      will override any default value set using any socket option.  Also
      note that the value of 0 is special in that it indicates no
      timeout should occur on this message.
	</t>

	<t hangText="sinfo_tsn:">
	For the receiving side, this field holds a Transmission
	<vspace blankLines="0"/>
	Sequence Number (TSN) that was assigned to one of the SCTP DATA
      chunks.  For the sending side, it is ignored.
	</t>

	<t hangText="sinfo_cumtsn:">
	This field will hold the current cumulative TSN as
	<vspace blankLines="0"/>
	known by the underlying SCTP layer.  Note that this field is
      ignored when sending.
	</t>

	<t hangText="sinfo_assoc_id:">
	The association handle field, sinfo_assoc_id, holds
	<vspace blankLines="0"/>
	the identifier for the association announced in the SCTP_COMM_UP
      notification.  All notifications for a given association have the
      same identifier.  This field is ignored for one-to-one style
      sockets.
	</t>

	</list>
	</t>

	<t>
   An sctp_sndrcvinfo item always corresponds to the data in msg_iov.</t>

	</section>

	<section title="Extended SCTP Header Information Structure (SCTP_EXTRCV) - DEPRECATED" anchor="section-5.3.3"><t>
   This cmsghdr structure specifies SCTP options for SCTP header
   information about a received message via recvmsg().  Note that this
   structure is an extended version of SCTP_SNDRCV (see <xref target="section-5.3.2"/>)
   and will only be received if the user has set the socket option
   SCTP_USE_EXT_RCVINFO (see <xref target="section-8.1.22"/>) to true in addition to any
   event subscription needed to receive ancillary data.  Note that data
   in the next message is not valid unless the current message is
   completely read, i.e., unless the MSG_EOR is set; in other words, if
   the application has more data to read from the current message, then
   no next-message information will be available.</t>

	<t>
   SCTP_NXTINFO (described in <xref target="section-5.3.6"/>) should be used when
   possible, since SCTP_EXTRCV is considered deprecated.</t>

	<texttable style="full"><ttcol> cmsg_level</ttcol>
	<ttcol> cmsg_type</ttcol>
	<ttcol> cmsg_data[]</ttcol>
	<c>IPPROTO_SCTP</c>
	<c>SCTP_EXTRCV</c>
	<c>struct sctp_extrcvinfo</c>
	<postamble>   The sctp_extrcvinfo structure is defined below:</postamble>
	</texttable>
	<figure><artwork><![CDATA[
struct sctp_extrcvinfo {
  uint16_t sinfo_stream;
  uint16_t sinfo_ssn;
  uint16_t sinfo_flags;
  uint32_t sinfo_ppid;
  uint32_t sinfo_context;
  uint32_t sinfo_pr_value;
  uint32_t sinfo_tsn;
  uint32_t sinfo_cumtsn;
  uint16_t serinfo_next_flags;
  uint16_t serinfo_next_stream;
  uint32_t serinfo_next_aid;
  uint32_t serinfo_next_length;
  uint32_t serinfo_next_ppid;
  sctp_assoc_t sinfo_assoc_id;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="-1"><t hangText="sinfo_*:">
	Please see <xref target="section-5.3.2"/> for details for these fields.
	<vspace blankLines="0"/>
	</t>

	<t hangText="serinfo_next_flags:">
	This bitmask will hold one or more of the
	<vspace blankLines="0"/>
	following values:
	<vspace blankLines="1"/>
	SCTP_NEXT_MSG_AVAIL:  This bit, when set to 1, indicates that
         next-message information is available; i.e., next_stream,
         next_aid, next_length, and next_ppid fields all have valid
         values.  If this bit is set to 0, then these fields are not
         valid and should be ignored.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_NEXT_MSG_ISCOMPLETE:">
	This bit, when set, indicates that the
	<vspace blankLines="0"/>
	next message is completely in the receive buffer.  The
         next_length field thus contains the entire message size.  If
         this flag is set to 0, then the next_length field only contains
         part of the message size, since the message is still being
         received (it is being partially delivered).
	</t>

	<t hangText="SCTP_NEXT_MSG_IS_UNORDERED:">
	This bit, when set, indicates that
	<vspace blankLines="0"/>
	the next message to be received was sent by the peer as
         unordered.  If this bit is not set (i.e., the bit is 0) the
         next message to be read is an ordered message in the stream
         specified.
	</t>

	<t hangText="SCTP_NEXT_MSG_IS_NOTIFICATION:">
	This bit, when set, indicates that
	<vspace blankLines="0"/>
	the next message to be received is not a message from the peer,
         but instead is a MSG_NOTIFICATION from the local SCTP stack.
	</t>

	</list>
	</t>

	<t hangText="serinfo_next_stream:">
	This value, when valid (see
	<vspace blankLines="0"/>
	serinfo_next_flags), contains the next stream number that will be
      received on a subsequent call to one of the receive message
      functions.
	</t>

	<t hangText="serinfo_next_aid:">
	This value, when valid (see serinfo_next_flags),
	<vspace blankLines="0"/>
	contains the next association identifier that will be received on
      a subsequent call to one of the receive message functions.
	</t>

	<t hangText="serinfo_next_length:">
	This value, when valid (see
	<vspace blankLines="0"/>
	serinfo_next_flags), contains the length of the next message that
      will be received on a subsequent call to one of the receive
      message functions.  Note that this length may be a partial length,
      depending on the settings of next_flags.
	</t>

	<t hangText="serinfo_next_ppid:">
	This value, when valid (see serinfo_next_flags),
	<vspace blankLines="0"/>
	contains the ppid of the next message that will be received on a
      subsequent call to one of the receive message functions.
	</t>

	</list>
	</t>

	</section>

	<section title="SCTP Send Information Structure (SCTP_SNDINFO)" anchor="section-5.3.4"><t><list style="hanging" hangIndent="-1"><t hangText="This cmsghdr structure specifies SCTP options for sendmsg().">
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<texttable style="full"><ttcol> cmsg_level</ttcol>
	<ttcol> cmsg_type</ttcol>
	<ttcol> cmsg_data[]</ttcol>
	<c>IPPROTO_SCTP</c>
	<c>SCTP_SNDINFO</c>
	<c>struct sctp_sndinfo</c>
	<postamble>   The sctp_sndinfo structure is defined below:</postamble>
	</texttable>
	<figure><artwork><![CDATA[
struct sctp_sndinfo {
  uint16_t snd_sid;
  uint16_t snd_flags;
  uint32_t snd_ppid;
  uint32_t snd_context;
  sctp_assoc_t snd_assoc_id;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="snd_sid:">
	This value holds the stream number to which the application
	<vspace blankLines="0"/>
	wishes to send this message.  If a sender specifies an invalid
      stream number, an error indication is returned and the call fails.
	</t>

	<t hangText="snd_flags:">
	This field may contain any of the following flags and is
	<vspace blankLines="0"/>
	composed of a bitwise OR of these values.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_UNORDERED:">
	This flag requests the unordered delivery of the
	<vspace blankLines="0"/>
	message.  If this flag is clear, the datagram is considered an
         ordered send.
	</t>

	<t hangText="SCTP_ADDR_OVER:">
	This flag, for a one-to-many style socket,
	<vspace blankLines="0"/>
	requests that the SCTP stack override the primary destination
         address with the address found with the sendto()/sendmsg call.
	</t>

	<t hangText="SCTP_ABORT:">
	Setting this flag causes the specified association to
	<vspace blankLines="0"/>
	abort by sending an ABORT message to the peer.  The ABORT chunk
         will contain an error cause of 'User Initiated Abort' with
         cause code 12.  The cause-specific information of this error
         cause is provided in msg_iov.
	</t>

	<t hangText="SCTP_EOF:">
	Setting this flag invokes the SCTP graceful shutdown
	<vspace blankLines="0"/>
	procedures on the specified association.  Graceful shutdown
         assures that all data queued by both endpoints is successfully
         transmitted before closing the association.
	</t>

	<t hangText="SCTP_SENDALL:">
	This flag, if set, will cause a one-to-many style
	<vspace blankLines="0"/>
	socket to send the message to all associations that are
         currently established on this socket.  For the one-to-one style
         socket, this flag has no effect.
	</t>

	</list>
	</t>

	<t hangText="snd_ppid:">
	This value in sendmsg() is an unsigned integer that is
	<vspace blankLines="0"/>
	passed to the remote end in each user message.  Please note that
      the SCTP stack performs no byte order modification of this field.
      For example, if the DATA chunk has to contain a given value in
      network byte order, the SCTP user has to perform the htonl()
      computation.
	</t>

	<t hangText="snd_context:">
	This value is an opaque 32-bit context datum that is
	<vspace blankLines="0"/>
	used in the sendmsg() function.  This value is passed back to the
      upper layer if an error occurs on the send of a message and is
      retrieved with each undelivered message.
	</t>

	<t hangText="snd_assoc_id:">
	The association handle field, sinfo_assoc_id, holds
	<vspace blankLines="0"/>
	the identifier for the association announced in the SCTP_COMM_UP
      notification.  All notifications for a given association have the
      same identifier.  This field is ignored for one-to-one style
      sockets.
	</t>

	</list>
	</t>

	<t>
   An sctp_sndinfo item always corresponds to the data in msg_iov.</t>

	</section>

	<section title="SCTP Receive Information Structure (SCTP_RCVINFO)" anchor="section-5.3.5"><t>
   This cmsghdr structure describes SCTP receive information about a
   received message through recvmsg().</t>

	<t>
   To enable the delivery of this information, an application must use
   the SCTP_RECVRCVINFO socket option (see <xref target="section-8.1.29"/>).</t>

	<texttable style="full"><ttcol> cmsg_level</ttcol>
	<ttcol> cmsg_type</ttcol>
	<ttcol> cmsg_data[]</ttcol>
	<c>IPPROTO_SCTP</c>
	<c>SCTP_RCVINFO</c>
	<c>struct sctp_rcvinfo</c>
	<postamble>   The sctp_rcvinfo structure is defined below:</postamble>
	</texttable>
	<figure><artwork><![CDATA[
struct sctp_rcvinfo {
  uint16_t rcv_sid;
  uint16_t rcv_ssn;
  uint16_t rcv_flags;
  uint32_t rcv_ppid;
  uint32_t rcv_tsn;
  uint32_t rcv_cumtsn;
  uint32_t rcv_context;
  sctp_assoc_t rcv_assoc_id;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="rcv_sid:">
	The SCTP stack places the message's stream number in this
	<vspace blankLines="0"/>
	value.
	</t>

	<t hangText="rcv_ssn:">
	This value contains the stream sequence number that the
	<vspace blankLines="0"/>
	remote endpoint placed in the DATA chunk.  For fragmented
      messages, this is the same number for all deliveries of the
      message (if more than one recvmsg() is needed to read the
      message).
	</t>

	<t hangText="rcv_flags:">
	This field may contain any of the following flags and is
	<vspace blankLines="0"/>
	composed of a bitwise OR of these values.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_UNORDERED:">
	This flag is present when the message was sent
	<vspace blankLines="0"/>
	unordered.
	</t>

	</list>
	</t>

	<t hangText="rcv_ppid:">
	This value is the same information that was passed by the
	<vspace blankLines="0"/>
	upper layer in the peer application.  Please note that the SCTP
      stack performs no byte order modification of this field.  For
      example, if the DATA chunk has to contain a given value in network
      byte order, the SCTP user has to perform the ntohl() computation.
	</t>

	<t hangText="rcv_tsn:">
	This field holds a TSN that was assigned to one of the SCTP
	<vspace blankLines="0"/>
	DATA chunks.
	</t>

	<t hangText="rcv_cumtsn:">
	This field will hold the current cumulative TSN as known
	<vspace blankLines="0"/>
	by the underlying SCTP layer.
	</t>

	<t hangText="rcv_context:">
	This value is an opaque 32-bit context datum that was
	<vspace blankLines="0"/>
	set by the user with the SCTP_CONTEXT socket option.  This value
      is passed back to the upper layer if an error occurs on the send
      of a message and is retrieved with each undelivered message.
	</t>

	<t hangText="rcv_assoc_id:">
	The association handle field, sinfo_assoc_id, holds
	<vspace blankLines="0"/>
	the identifier for the association announced in the SCTP_COMM_UP
      notification.  All notifications for a given association have the
      same identifier.  This field is ignored for one-to-one style
      sockets.
	</t>

	</list>
	</t>

	<t>
   An sctp_rcvinfo item always corresponds to the data in msg_iov.</t>

	</section>

	<section title="SCTP Next Receive Information Structure (SCTP_NXTINFO)" anchor="section-5.3.6"><t>
   This cmsghdr structure describes SCTP receive information of the next
   message that will be delivered through recvmsg() if this information
   is already available when delivering the current message.</t>

	<t>
   To enable the delivery of this information, an application must use
   the SCTP_RECVNXTINFO socket option (see <xref target="section-8.1.30"/>).</t>

	<texttable style="full"><ttcol> cmsg_level</ttcol>
	<ttcol> cmsg_type</ttcol>
	<ttcol> cmsg_data[]</ttcol>
	<c>IPPROTO_SCTP</c>
	<c>SCTP_NXTINFO</c>
	<c>struct sctp_nxtinfo</c>
	<postamble>   The sctp_nxtinfo structure is defined below:</postamble>
	</texttable>
	<figure><artwork><![CDATA[
struct sctp_nxtinfo {
  uint16_t nxt_sid;
  uint16_t nxt_flags;
  uint32_t nxt_ppid;
  uint32_t nxt_length;
  sctp_assoc_t nxt_assoc_id;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="nxt_sid:">
	The SCTP stack places the next message's stream number in
	<vspace blankLines="0"/>
	this value.
	</t>

	<t hangText="nxt_flags:">
	This field may contain any of the following flags and is
	<vspace blankLines="0"/>
	composed of a bitwise OR of these values.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_UNORDERED:">
	This flag is present when the next message was
	<vspace blankLines="0"/>
	sent unordered.
	</t>

	<t hangText="SCTP_COMPLETE:">
	This flag indicates that the entire message has
	<vspace blankLines="0"/>
	been received and is in the socket buffer.  Note that this has
         special implications with respect to the nxt_length field; see
         the description for nxt_length below.
	</t>

	<t hangText="SCTP_NOTIFICATION:">
	This flag is present when the next message is
	<vspace blankLines="0"/>
	not a user message but instead is a notification.
	</t>

	</list>
	</t>

	<t hangText="nxt_ppid:">
	This value is the same information that was passed by the
	<vspace blankLines="0"/>
	upper layer in the peer application for the next message.  Please
      note that the SCTP stack performs no byte order modification of
      this field.  For example, if the DATA chunk has to contain a given
      value in network byte order, the SCTP user has to perform the
      ntohl() computation.
	</t>

	<t hangText="nxt_length:">
	This value is the length of the message currently within
	<vspace blankLines="0"/>
	the socket buffer.  This might NOT be the entire length of the
      message, since a partial delivery may be in progress.  Only if the
      flag SCTP_COMPLETE is set in the nxt_flags field does this field
      represent the size of the entire next message.
	</t>

	<t hangText="nxt_assoc_id:">
	The association handle field of the next message,
	<vspace blankLines="0"/>
	nxt_assoc_id, holds the identifier for the association announced
      in the SCTP_COMM_UP notification.  All notifications for a given
      association have the same identifier.  This field is ignored for
      one-to-one style sockets.
	</t>

	</list>
	</t>

	</section>

	<section title="SCTP PR-SCTP Information Structure (SCTP_PRINFO)" anchor="section-5.3.7"><t><list style="hanging" hangIndent="-1"><t hangText="This cmsghdr structure specifies SCTP options for sendmsg().">
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<texttable style="full"><ttcol> cmsg_level</ttcol>
	<ttcol> cmsg_type</ttcol>
	<ttcol> cmsg_data[]</ttcol>
	<c>IPPROTO_SCTP</c>
	<c>SCTP_PRINFO</c>
	<c>struct sctp_prinfo</c>
	<postamble>   The sctp_prinfo structure is defined below:</postamble>
	</texttable>
	<figure><artwork><![CDATA[
struct sctp_prinfo {
  uint16_t pr_policy;
  uint32_t pr_value;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="pr_policy:">
	This specifies which Partially Reliable SCTP (PR-SCTP)
	<vspace blankLines="0"/>
	policy is used.  Using SCTP_PR_SCTP_NONE results in a reliable
      transmission.  When SCTP_PR_SCTP_TTL is used, the PR-SCTP policy
      "timed reliability" defined in <xref target="RFC3758"/> is used.  In this case,
      the lifetime is provided in pr_value.
	</t>

	<t hangText="pr_value:">
	The meaning of this field depends on the PR-SCTP policy
	<vspace blankLines="0"/>
	specified by the pr_policy field.  It is ignored when
      SCTP_PR_SCTP_NONE is specified.  In the case of SCTP_PR_SCTP_TTL,
      the lifetime in milliseconds is specified.
	</t>

	</list>
	</t>

	<t>
   An sctp_prinfo item always corresponds to the data in msg_iov.</t>

	</section>

	<section title="SCTP AUTH Information Structure (SCTP_AUTHINFO)" anchor="section-5.3.8"><t><list style="hanging" hangIndent="-1"><t hangText="This cmsghdr structure specifies SCTP options for sendmsg().">
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<texttable style="full"><ttcol> cmsg_level</ttcol>
	<ttcol> cmsg_type</ttcol>
	<ttcol> cmsg_data[]</ttcol>
	<c>IPPROTO_SCTP</c>
	<c>SCTP_AUTHINFO</c>
	<c>struct sctp_authinfo</c>
	<postamble>   The sctp_authinfo structure is defined below:</postamble>
	</texttable>
	<figure><artwork><![CDATA[
struct sctp_authinfo {
  uint16_t auth_keynumber;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="auth_keynumber:">
	This specifies the shared key identifier used for
	<vspace blankLines="0"/>
	sending the user message.
	</t>

	</list>
	</t>

	<t>
   An sctp_authinfo item always corresponds to the data in msg_iov.
   Please note that the SCTP implementation must not bundle user
   messages that need to be authenticated using different shared key
   identifiers.</t>

	</section>

	<section title="SCTP Destination IPv4 Address Structure (SCTP_DSTADDRV4)" anchor="section-5.3.9"><t><list style="hanging" hangIndent="-1"><t hangText="This cmsghdr structure specifies SCTP options for sendmsg().">
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<texttable style="full"><ttcol> cmsg_level</ttcol>
	<ttcol> cmsg_type</ttcol>
	<ttcol> cmsg_data[]</ttcol>
	<c>IPPROTO_SCTP</c>
	<c>SCTP_DSTADDRV4</c>
	<c>struct in_addr</c>
	</texttable>
	<t>
   This ancillary data can be used to provide more than one destination
   address to sendmsg().  It can be used to implement sctp_sendv() using
   sendmsg().</t>

	</section>

	<section title="SCTP Destination IPv6 Address Structure (SCTP_DSTADDRV6)" anchor="section-5.3.10"><t><list style="hanging" hangIndent="-1"><t hangText="This cmsghdr structure specifies SCTP options for sendmsg().">
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<texttable style="full"><ttcol> cmsg_level</ttcol>
	<ttcol> cmsg_type</ttcol>
	<ttcol> cmsg_data[]</ttcol>
	<c>IPPROTO_SCTP</c>
	<c>SCTP_DSTADDRV6</c>
	<c>struct in6_addr</c>
	</texttable>
	<t>
   This ancillary data can be used to provide more than one destination
   address to sendmsg().  It can be used to implement sctp_sendv() using
   sendmsg().</t>

	</section>

	</section>

	</section>

	<section title="SCTP Events and Notifications" anchor="section-6"><t>
   An SCTP application may need to understand and process events and
   errors that happen on the SCTP stack.  These events include network
   status changes, association startups, remote operational errors, and
   undeliverable messages.  All of these can be essential for the
   application.</t>

	<t>
   When an SCTP application layer does a recvmsg(), the message read is
   normally a data message from a peer endpoint.  If the application
   wishes to have the SCTP stack deliver notifications of non-data
   events, it sets the appropriate socket option for the notifications
   it wants.  See <xref target="section-6.2"/> for these socket options.  When a
   notification arrives, recvmsg() returns the notification in the
   application-supplied data buffer via msg_iov, and sets
   MSG_NOTIFICATION in msg_flags.</t>

	<t>
   This section details the notification structures.  Every notification
   structure carries some common fields that provide general
   information.</t>

	<t>
   A recvmsg() call will return only one notification at a time.  Just
   as when reading normal data, it may return part of a notification if
   the msg_iov buffer is not large enough.  If a single read is not
   sufficient, msg_flags will have MSG_EOR clear.  The user must finish
   reading the notification before subsequent data can arrive.</t>

	<section title="SCTP Notification Structure" anchor="section-6.1"><t>
   The notification structure is defined as the union of all
   notification types.</t>

	<figure><artwork><![CDATA[
union sctp_notification {
  struct sctp_tlv {
    uint16_t sn_type; /* Notification type. */
    uint16_t sn_flags;
    uint32_t sn_length;
  } sn_header;
  struct sctp_assoc_change sn_assoc_change;
  struct sctp_paddr_change sn_paddr_change;
  struct sctp_remote_error sn_remote_error;
  struct sctp_send_failed sn_send_failed;
  struct sctp_shutdown_event sn_shutdown_event;
  struct sctp_adaptation_event sn_adaptation_event;
  struct sctp_pdapi_event sn_pdapi_event;
  struct sctp_authkey_event sn_auth_event;
  struct sctp_sender_dry_event sn_sender_dry_event;
  struct sctp_send_failed_event sn_send_failed_event;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="sn_type:">
	The following list describes the SCTP notification and
	<vspace blankLines="0"/>
	event types for the field sn_type.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_ASSOC_CHANGE:">
	This tag indicates that an association has
	<vspace blankLines="0"/>
	either been opened or closed.  Refer to <xref target="section-6.1.1"/> for
         details.
	</t>

	<t hangText="SCTP_PEER_ADDR_CHANGE:">
	This tag indicates that an address that is
	<vspace blankLines="0"/>
	part of an existing association has experienced a change of
         state (e.g., a failure or return to service of the reachability
         of an endpoint via a specific transport address).  Please see
         <xref target="section-6.1.2"/> for data structure details.
	</t>

	<t hangText="SCTP_REMOTE_ERROR:">
	The attached error message is an Operation
	<vspace blankLines="0"/>
	Error message received from the remote peer.  It includes the
         complete TLV sent by the remote endpoint.  See <xref target="section-6.1.3"/>
         for the detailed format.
	</t>

	<t hangText="SCTP_SEND_FAILED_EVENT:">
	The attached datagram could not be sent
	<vspace blankLines="0"/>
	to the remote endpoint.  This structure includes the original
         SCTP_SNDINFO that was used in sending this message; i.e., this
         structure uses the sctp_sndinfo per <xref target="section-6.1.11"/>.
	</t>

	<t hangText="SCTP_SHUTDOWN_EVENT:">
	The peer has sent a SHUTDOWN.  No further
	<vspace blankLines="0"/>
	data should be sent on this socket.
	</t>

	<t hangText="SCTP_ADAPTATION_INDICATION:">
	This notification holds the peer's
	<vspace blankLines="0"/>
	indicated adaptation layer.  Please see <xref target="section-6.1.6"/>.
	</t>

	<t hangText="SCTP_PARTIAL_DELIVERY_EVENT:">
	This notification is used to tell a
	<vspace blankLines="0"/>
	receiver that the partial delivery has been aborted.  This may
         indicate that the association is about to be aborted.  Please
         see <xref target="section-6.1.7"/>.
	</t>

	<t hangText="SCTP_AUTHENTICATION_EVENT:">
	This notification is used to tell a
	<vspace blankLines="0"/>
	receiver that either an error occurred on authentication, or a
         new key was made active.  See <xref target="section-6.1.8"/>.
	</t>

	<t hangText="SCTP_SENDER_DRY_EVENT:">
	This notification is used to inform the
	<vspace blankLines="0"/>
	application that the sender has no more user data queued for
         transmission or retransmission.  See <xref target="section-6.1.9"/>.
	</t>

	</list>
	</t>

	<t hangText="sn_flags:">
	These are notification-specific flags.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sn_length:">
	This is the length of the whole sctp_notification
	<vspace blankLines="0"/>
	structure, including the sn_type, sn_flags, and sn_length fields.
	</t>

	</list>
	</t>

	<section title="SCTP_ASSOC_CHANGE" anchor="section-6.1.1"><t>
   Communication notifications inform the application that an SCTP
   association has either begun or ended.  The identifier for a new
   association is provided by this notification.  The notification
   information has the following format:</t>

	<figure><artwork><![CDATA[
struct sctp_assoc_change {
  uint16_t sac_type;
  uint16_t sac_flags;
  uint32_t sac_length;
  uint16_t sac_state;
  uint16_t sac_error;
  uint16_t sac_outbound_streams;
  uint16_t sac_inbound_streams;
  sctp_assoc_t sac_assoc_id;
  uint8_t  sac_info[];
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="-1"><t hangText="sac_type:">
	This field should be set to SCTP_ASSOC_CHANGE.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sac_flags:">
	This field is currently unused.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sac_length:">
	This field is the total length of the notification data,
	<vspace blankLines="0"/>
	including the notification header.
	</t>

	<t hangText="sac_state:">
	This field holds one of a number of values that
	<vspace blankLines="0"/>
	communicate the event that happened to the association.  These
      values include
	<vspace blankLines="1"/>
	SCTP_COMM_UP:  A new association is now ready, and data may be
         exchanged with this peer.  When an association has been
         established successfully, this notification should be the
         first one.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_COMM_LOST:">
	The association has failed.  The association is
	<vspace blankLines="0"/>
	now in the closed state.  If SEND_FAILED notifications are
         turned on, an SCTP_COMM_LOST is accompanied by a series of
         SCTP_SEND_FAILED_EVENT events, one for each outstanding
         message.
	</t>

	<t hangText="SCTP_RESTART:">
	SCTP has detected that the peer has restarted.
	<vspace blankLines="0"/>
	</t>

	<t hangText="SCTP_SHUTDOWN_COMP:">
	The association has gracefully closed.
	<vspace blankLines="0"/>
	</t>

	<t hangText="SCTP_CANT_STR_ASSOC:">
	The association setup failed.  If
	<vspace blankLines="0"/>
	non-blocking mode is set and data was sent (on a one-to-many
         style socket), an SCTP_CANT_STR_ASSOC is accompanied by a
         series of SCTP_SEND_FAILED_EVENT events, one for each
         outstanding message.
	</t>

	</list>
	</t>

	<t hangText="sac_error:">
	If the state was reached due to an error condition (e.g.,
	<vspace blankLines="0"/>
	SCTP_COMM_LOST), any relevant error information is available in
      this field.  This corresponds to the protocol error codes defined
      in <xref target="RFC4960"/>.
	</t>

	<t hangText="sac_outbound_streams and sac_inbound_streams:">
	The maximum number of
	<vspace blankLines="0"/>
	streams allowed in each direction is available in
      sac_outbound_streams and sac_inbound streams.
	</t>

	<t hangText="sac_assoc_id:">
	The sac_assoc_id field holds the identifier for the
	<vspace blankLines="0"/>
	association.  All notifications for a given association have the
      same association identifier.  For a one-to-one style socket, this
      field is ignored.
	</t>

	<t hangText="sac_info:">
	If sac_state is SCTP_COMM_LOST and an ABORT chunk was
	<vspace blankLines="0"/>
	received for this association, sac_info[] contains the complete
      ABORT chunk as defined in Section 3.3.7 of the SCTP specification
      <xref target="RFC4960"/>.  If sac_state is SCTP_COMM_UP or SCTP_RESTART, sac_info
      may contain an array of uint8_t describing the features that the
      current association supports.  Features may include
	<list style="hanging" hangIndent="3"><t hangText="SCTP_ASSOC_SUPPORTS_PR:">
	Both endpoints support the protocol
	<vspace blankLines="0"/>
	extension described in <xref target="RFC3758"/>.
	</t>

	<t hangText="SCTP_ASSOC_SUPPORTS_AUTH:">
	Both endpoints support the protocol
	<vspace blankLines="0"/>
	extension described in <xref target="RFC4895"/>.
	</t>

	<t hangText="SCTP_ASSOC_SUPPORTS_ASCONF:">
	Both endpoints support the protocol
	<vspace blankLines="0"/>
	extension described in <xref target="RFC5061"/>.
	</t>

	<t hangText="SCTP_ASSOC_SUPPORTS_MULTIBUF:">
	For a one-to-many style socket, the
	<vspace blankLines="0"/>
	local endpoints use separate send and/or receive buffers for
         each SCTP association.
	</t>

	</list>
	</t>

	</list>
	</t>

	</section>

	<section title="SCTP_PEER_ADDR_CHANGE" anchor="section-6.1.2"><t>
   When a destination address of a multi-homed peer encounters a state
   change, a peer address change event is sent.  The notification has
   the following format:</t>

	<figure><artwork><![CDATA[
struct sctp_paddr_change {
  uint16_t spc_type;
  uint16_t spc_flags;
  uint32_t spc_length;
  struct sockaddr_storage spc_aaddr;
  uint32_t spc_state;
  uint32_t spc_error;
  sctp_assoc_t spc_assoc_id;
}
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="-1"><t hangText="spc_type:">
	This field should be set to SCTP_PEER_ADDR_CHANGE.
	<vspace blankLines="0"/>
	</t>

	<t hangText="spc_flags:">
	This field is currently unused.
	<vspace blankLines="0"/>
	</t>

	<t hangText="spc_length:">
	This field is the total length of the notification data,
	<vspace blankLines="0"/>
	including the notification header.
	</t>

	<t hangText="spc_aaddr:">
	The affected address field holds the remote peer's
	<vspace blankLines="0"/>
	address that is encountering the change of state.
	</t>

	<t hangText="spc_state:">
	This field holds one of a number of values that
	<vspace blankLines="0"/>
	communicate the event that happened to the address.  They include
	<vspace blankLines="1"/>
	SCTP_ADDR_AVAILABLE:  This address is now reachable.  This
         notification is provided whenever an address becomes reachable.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_ADDR_UNREACHABLE:">
	The address specified can no longer be
	<vspace blankLines="0"/>
	reached.  Any data sent to this address is rerouted to an
         alternate until this address becomes reachable.  This
         notification is provided whenever an address becomes
         unreachable.
	</t>

	<t hangText="SCTP_ADDR_REMOVED:">
	The address is no longer part of the
	<vspace blankLines="0"/>
	association.
	</t>

	<t hangText="SCTP_ADDR_ADDED:">
	The address is now part of the association.
	<vspace blankLines="0"/>
	</t>

	<t hangText="SCTP_ADDR_MADE_PRIM:">
	This address has now been made the primary
	<vspace blankLines="0"/>
	destination address.  This notification is provided whenever an
         address is made primary.
	</t>

	</list>
	</t>

	<t hangText="spc_error:">
	If the state was reached due to any error condition
	<vspace blankLines="0"/>
	(e.g., SCTP_ADDR_UNREACHABLE), any relevant error information is
      available in this field.
	</t>

	<t hangText="spc_assoc_id:">
	The spc_assoc_id field holds the identifier for the
	<vspace blankLines="0"/>
	association.  All notifications for a given association have the
      same association identifier.  For a one-to-one style socket, this
      field is ignored.
	</t>

	</list>
	</t>

	</section>

	<section title="SCTP_REMOTE_ERROR" anchor="section-6.1.3"><t>
   A remote peer may send an Operation Error message to its peer.  This
   message indicates a variety of error conditions on an association.
   The entire ERROR chunk as it appears on the wire is included in an
   SCTP_REMOTE_ERROR event.  Please refer to the SCTP specification
   <xref target="RFC4960"/> and any extensions for a list of possible error formats.
   An SCTP error notification has the following format:</t>

	<figure><artwork><![CDATA[
struct sctp_remote_error {
  uint16_t sre_type;
  uint16_t sre_flags;
  uint32_t sre_length;
  uint16_t sre_error;
  sctp_assoc_t sre_assoc_id;
  uint8_t  sre_data[];
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="-1"><t hangText="sre_type:">
	This field should be set to SCTP_REMOTE_ERROR.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sre_flags:">
	This field is currently unused.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sre_length:">
	This field is the total length of the notification data,
	<vspace blankLines="0"/>
	including the notification header and the contents of sre_data.
	</t>

	<t hangText="sre_error:">
	This value represents one of the Operation Error causes
	<vspace blankLines="0"/>
	defined in the SCTP specification <xref target="RFC4960"/>, in network byte
      order.
	</t>

	<t hangText="sre_assoc_id:">
	The sre_assoc_id field holds the identifier for the
	<vspace blankLines="0"/>
	association.  All notifications for a given association have the
      same association identifier.  For a one-to-one style socket, this
      field is ignored.
	</t>

	<t hangText="sre_data:">
	This contains the ERROR chunk as defined in Section 3.3.10
	<vspace blankLines="0"/>
	of the SCTP specification <xref target="RFC4960"/>.
	</t>

	</list>
	</t>

	</section>

	<section title="SCTP_SEND_FAILED - DEPRECATED" anchor="section-6.1.4"><t>
   Please note that this notification is deprecated.  Use
   SCTP_SEND_FAILED_EVENT instead.</t>

	<t>
   If SCTP cannot deliver a message, it can return back the message as a
   notification if the SCTP_SEND_FAILED event is enabled.  The
   notification has the following format:</t>

	<figure><artwork><![CDATA[
struct sctp_send_failed {
  uint16_t ssf_type;
  uint16_t ssf_flags;
  uint32_t ssf_length;
  uint32_t ssf_error;
  struct sctp_sndrcvinfo ssf_info;
  sctp_assoc_t ssf_assoc_id;
  uint8_t  ssf_data[];
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="-1"><t hangText="ssf_type:">
	This field should be set to SCTP_SEND_FAILED.
	<vspace blankLines="0"/>
	</t>

	<t hangText="ssf_flags:">
	The flag value will take one of the following values:
	<vspace blankLines="1"/>
	SCTP_DATA_UNSENT:  This value indicates that the data was never
         put on the wire.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_DATA_SENT:">
	This value indicates that the data was put on the
	<vspace blankLines="0"/>
	wire.  Note that this does not necessarily mean that the data
         was (or was not) successfully delivered.
	</t>

	</list>
	</t>

	<t hangText="ssf_length:">
	This field is the total length of the notification data,
	<vspace blankLines="0"/>
	including the notification header and the payload in ssf_data.
	</t>

	<t hangText="ssf_error:">
	This value represents the reason why the send failed, and
	<vspace blankLines="0"/>
	if set, will be an SCTP protocol error code as defined in
      Section 3.3.10 of <xref target="RFC4960"/>.
	</t>

	<t hangText="ssf_info:">
	This field includes the ancillary data (struct
	<vspace blankLines="0"/>
	sctp_sndrcvinfo) used to send the undelivered message.  Regardless
      of whether ancillary data is used or not, the ssf_info.sinfo_flags
      field indicates whether the complete message or only part of the
      message is returned in ssf_data.  If only part of the message is
      returned, it means that the part that is not present has been sent
      successfully to the peer.
	<vspace blankLines="1"/>
	If the complete message cannot be sent, the SCTP_DATA_NOT_FRAG
      flag is set in ssf_info.sinfo_flags.  If the first part of the
      message is sent successfully, SCTP_DATA_LAST_FRAG is set.  This
      means that the tail end of the message is returned in ssf_data.
	</t>

	<t hangText="ssf_assoc_id:">
	The ssf_assoc_id field, ssf_assoc_id, holds the
	<vspace blankLines="0"/>
	identifier for the association.  All notifications for a given
      association have the same association identifier.  For a one-to-
      one style socket, this field is ignored.
	</t>

	<t hangText="ssf_data:">
	The undelivered message or part of the undelivered message
	<vspace blankLines="0"/>
	will be present in the ssf_data field.  Note that the
      ssf_info.sinfo_flags field as noted above should be used to
      determine whether a complete message or just a piece of the
      message is present.  Note that only user data is present in this
      field; any chunk headers or SCTP common headers must be removed by
      the SCTP stack.
	</t>

	</list>
	</t>

	</section>

	<section title="SCTP_SHUTDOWN_EVENT" anchor="section-6.1.5"><t>
   When a peer sends a SHUTDOWN, SCTP delivers this notification to
   inform the application that it should cease sending data.</t>

	<figure><artwork><![CDATA[
    struct sctp_shutdown_event {
        uint16_t sse_type;
        uint16_t sse_flags;
        uint32_t sse_length;
        sctp_assoc_t sse_assoc_id;
    };
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="-1"><t hangText="sse_type:">
	This field should be set to SCTP_SHUTDOWN_EVENT.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sse_flags:">
	This field is currently unused.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sse_length:">
	This field is the total length of the notification data,
	<vspace blankLines="0"/>
	including the notification header.  It will generally be
      sizeof(struct sctp_shutdown_event).
	</t>

	<t hangText="sse_assoc_id:">
	The sse_assoc_id field holds the identifier for the
	<vspace blankLines="0"/>
	association.  All notifications for a given association have the
      same association identifier.  For a one-to-one style socket, this
      field is ignored.
	</t>

	</list>
	</t>

	</section>

	<section title="SCTP_ADAPTATION_INDICATION" anchor="section-6.1.6"><t>
   When a peer sends an Adaptation Layer Indication parameter as
   described in <xref target="RFC5061"/>, SCTP delivers this notification to inform the
   application about the peer's adaptation layer indication.</t>

	<figure><artwork><![CDATA[
struct sctp_adaptation_event {
  uint16_t sai_type;
  uint16_t sai_flags;
  uint32_t sai_length;
  uint32_t sai_adaptation_ind;
  sctp_assoc_t sai_assoc_id;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="-1"><t hangText="sai_type:">
	This field should be set to SCTP_ADAPTATION_INDICATION.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sai_flags:">
	This field is currently unused.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sai_length:">
	This field is the total length of the notification data,
	<vspace blankLines="0"/>
	including the notification header.  It will generally be
      sizeof(struct sctp_adaptation_event).
	</t>

	<t hangText="sai_adaptation_ind:">
	This field holds the bit array sent by the peer
	<vspace blankLines="0"/>
	in the Adaptation Layer Indication parameter.
	</t>

	<t hangText="sai_assoc_id:">
	The sai_assoc_id field holds the identifier for the
	<vspace blankLines="0"/>
	association.  All notifications for a given association have the
      same association identifier.  For a one-to-one style socket, this
      field is ignored.
	</t>

	</list>
	</t>

	</section>

	<section title="SCTP_PARTIAL_DELIVERY_EVENT" anchor="section-6.1.7"><t>
   When a receiver is engaged in a partial delivery of a message, this
   notification will be used to indicate various events.</t>

	<figure><artwork><![CDATA[
struct sctp_pdapi_event {
  uint16_t pdapi_type;
  uint16_t pdapi_flags;
  uint32_t pdapi_length;
]]></artwork>
	</figure>
	<figure><artwork><![CDATA[
  uint32_t pdapi_indication;
  uint32_t pdapi_stream;
  uint32_t pdapi_seq;
  sctp_assoc_t pdapi_assoc_id;
};

pdapi_type:  This field should be set to SCTP_PARTIAL_DELIVERY_EVENT.

pdapi_flags:  This field is currently unused.

pdapi_length:  This field is the total length of the notification
   data, including the notification header.  It will generally be
   sizeof(struct sctp_pdapi_event).

pdapi_indication:  This field holds the indication being sent to the
   application.  Currently, there is only one defined value:

   SCTP_PARTIAL_DELIVERY_ABORTED:  This indicates that the partial
      delivery of a user message has been aborted.  This happens, for
      example, if an association is aborted while a partial delivery
      is going on or the user message gets abandoned using PR-SCTP
      while the partial delivery of this message is going on.

pdapi_stream:  This field holds the stream on which the partial
   delivery event happened.

pdapi_seq:  This field holds the stream sequence number that was
   being partially delivered.

pdapi_assoc_id:  The pdapi_assoc_id field holds the identifier for
   the association.  All notifications for a given association have
   the same association identifier.  For a one-to-one style socket,
   this field is ignored.
]]></artwork>
	</figure>
	</section>

	<section title="SCTP_AUTHENTICATION_EVENT" anchor="section-6.1.8"><t>
   <xref target="RFC4895"/> defines an extension to authenticate SCTP messages.  The
   following notification is used to report different events relating to
   the use of this extension.</t>

	<figure><artwork><![CDATA[
struct sctp_authkey_event {
  uint16_t auth_type;
  uint16_t auth_flags;
  uint32_t auth_length;
  uint16_t auth_keynumber;
  uint32_t auth_indication;
  sctp_assoc_t auth_assoc_id;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="-1"><t hangText="auth_type:">
	This field should be set to SCTP_AUTHENTICATION_EVENT.
	<vspace blankLines="0"/>
	</t>

	<t hangText="auth_flags:">
	This field is currently unused.
	<vspace blankLines="0"/>
	</t>

	<t hangText="auth_length:">
	This field is the total length of the notification
	<vspace blankLines="0"/>
	data, including the notification header.  It will generally be
      sizeof(struct sctp_authkey_event).
	</t>

	<t hangText="auth_keynumber:">
	This field holds the key number for the affected key
	<vspace blankLines="0"/>
	indicated in the event (depends on auth_indication).
	</t>

	<t hangText="auth_indication:">
	This field holds the error or indication being
	<vspace blankLines="0"/>
	reported.  The following values are currently defined:
	<vspace blankLines="1"/>
	SCTP_AUTH_NEW_KEY:  This report indicates that a new key has been
         made active (used for the first time by the peer) and is now
         the active key.  The auth_keynumber field holds the user-
         specified key number.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_AUTH_NO_AUTH:">
	This report indicates that the peer does not
	<vspace blankLines="0"/>
	support SCTP authentication as defined in <xref target="RFC4895"/>.
	</t>

	<t hangText="SCTP_AUTH_FREE_KEY:">
	This report indicates that the SCTP
	<vspace blankLines="0"/>
	implementation will no longer use the key identifier specified
         in auth_keynumber.
	</t>

	</list>
	</t>

	<t hangText="auth_assoc_id:">
	The auth_assoc_id field holds the identifier for the
	<vspace blankLines="0"/>
	association.  All notifications for a given association have the
      same association identifier.  For a one-to-one style socket, this
      field is ignored.
	</t>

	</list>
	</t>

	</section>

	<section title="SCTP_SENDER_DRY_EVENT" anchor="section-6.1.9"><t>
   When the SCTP stack has no more user data to send or retransmit, this
   notification is given to the user.  Also, at the time when a user app
   subscribes to this event, if there is no data to be sent or
   retransmit, the stack will immediately send up this notification.</t>

	<figure><artwork><![CDATA[
struct sctp_sender_dry_event {
  uint16_t sender_dry_type;
  uint16_t sender_dry_flags;
  uint32_t sender_dry_length;
  sctp_assoc_t sender_dry_assoc_id;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="-1"><t hangText="sender_dry_type:">
	This field should be set to SCTP_SENDER_DRY_EVENT.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sender_dry_flags:">
	This field is currently unused.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sender_dry_length:">
	This field is the total length of the
	<vspace blankLines="0"/>
	notification data, including the notification header.  It will
      generally be sizeof(struct sctp_sender_dry_event).
	</t>

	<t hangText="sender_dry_assoc_id:">
	The sender_dry_assoc_id field holds the
	<vspace blankLines="0"/>
	identifier for the association.  All notifications for a given
      association have the same association identifier.  For a one-to-
      one style socket, this field is ignored.
	</t>

	</list>
	</t>

	</section>

	<section title="SCTP_NOTIFICATIONS_STOPPED_EVENT" anchor="section-6.1.10"><t>
   SCTP notifications, when subscribed to, are reliable.  They are
   always delivered as long as there is space in the socket receive
   buffer.  However, if an implementation experiences a notification
   storm, it may run out of socket buffer space.  When this occurs, it
   may wish to disable notifications.  If the implementation chooses to
   do this, it will append a final notification
   SCTP_NOTIFICATIONS_STOPPED_EVENT.  This notification is a union
   sctp_notification, where only the sctp_tlv structure (see the union
   above) is used.  It only contains this type in the sn_type field, the
   sn_length field set to the size of an sctp_tlv structure, and the
   sn_flags set to 0.  If an application receives this notification, it
   will need to re-subscribe to any notifications of interest to it,
   except for the sctp_data_io_event (note that SCTP_EVENTS is
   deprecated).</t>

	<t>
   An endpoint is automatically subscribed to this event as soon as it
   is subscribed to any event other than data io events.</t>

	</section>

	<section title="SCTP_SEND_FAILED_EVENT" anchor="section-6.1.11"><t>
   If SCTP cannot deliver a message, it can return back the message as a
   notification if the SCTP_SEND_FAILED_EVENT event is enabled.  The
   notification has the following format:</t>

	<figure><artwork><![CDATA[
struct sctp_send_failed_event {
  uint16_t ssfe_type;
  uint16_t ssfe_flags;
  uint32_t ssfe_length;
  uint32_t ssfe_error;
  struct sctp_sndinfo ssfe_info;
  sctp_assoc_t ssfe_assoc_id;
  uint8_t  ssfe_data[];
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="-1"><t hangText="ssfe_type:">
	This field should be set to SCTP_SEND_FAILED_EVENT.
	<vspace blankLines="0"/>
	</t>

	<t hangText="ssfe_flags:">
	The flag value will take one of the following values:
	<vspace blankLines="1"/>
	SCTP_DATA_UNSENT:  This value indicates that the data was never
         put on the wire.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_DATA_SENT:">
	This value indicates that the data was put on the
	<vspace blankLines="0"/>
	wire.  Note that this does not necessarily mean that the data
         was (or was not) successfully delivered.
	</t>

	</list>
	</t>

	<t hangText="ssfe_length:">
	This field is the total length of the notification
	<vspace blankLines="0"/>
	data, including the notification header and the payload in
      ssf_data.
	</t>

	<t hangText="ssfe_error:">
	This value represents the reason why the send failed,
	<vspace blankLines="0"/>
	and if set, will be an SCTP protocol error code as defined in
      Section 3.3.10 of <xref target="RFC4960"/>.
	</t>

	<t hangText="ssfe_info:">
	This field includes the ancillary data (struct
	<vspace blankLines="0"/>
	sctp_sndinfo) used to send the undelivered message.  Regardless of
      whether ancillary data is used or not, the ssfe_info.sinfo_flags
      field indicates whether the complete message or only part of the
      message is returned in ssf_data.  If only part of the message is
      returned, it means that the part that is not present has been sent
      successfully to the peer.
	<vspace blankLines="1"/>
	If the complete message cannot be sent, the SCTP_DATA_NOT_FRAG
      flag is set in ssfe_info.sinfo_flags.  If the first part of the
      message is sent successfully, SCTP_DATA_LAST_FRAG is set.  This
      means that the tail end of the message is returned in ssf_data.
	</t>

	<t hangText="ssfe_assoc_id:">
	The ssfe_assoc_id field, ssf_assoc_id, holds the
	<vspace blankLines="0"/>
	identifier for the association.  All notifications for a given
      association have the same association identifier.  For a one-to-
      one style socket, this field is ignored.
	</t>

	<t hangText="ssfe_data:">
	The undelivered message or part of the undelivered
	<vspace blankLines="0"/>
	message will be present in the ssf_data field.  Note that the
      ssf_info.sinfo_flags field as noted above should be used to
      determine whether a complete message or just a piece of the
      message is present.  Note that only user data is present in this
      field; any chunk headers or SCTP common headers must be removed by
      the SCTP stack.
	</t>

	</list>
	</t>

	</section>

	</section>

	<section title="Notification Interest Options" anchor="section-6.2"><section title="SCTP_EVENTS Option - DEPRECATED" anchor="section-6.2.1"><t>
   Please note that this option is deprecated.  Use the SCTP_EVENT
   option described in <xref target="section-6.2.2"/> instead.</t>

	<t>
   To receive SCTP event notifications, an application registers its
   interest by setting the SCTP_EVENTS socket option.  The application
   then uses recvmsg() to retrieve notifications.  A notification is
   stored in the data part (msg_iov) of the msghdr structure.  The
   socket option uses the following structure:</t>

	<figure><artwork><![CDATA[
struct sctp_event_subscribe {
  uint8_t sctp_data_io_event;
  uint8_t sctp_association_event;
  uint8_t sctp_address_event;
  uint8_t sctp_send_failure_event;
  uint8_t sctp_peer_error_event;
  uint8_t sctp_shutdown_event;
  uint8_t sctp_partial_delivery_event;
  uint8_t sctp_adaptation_layer_event;
  uint8_t sctp_authentication_event;
  uint8_t sctp_sender_dry_event;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="sctp_data_io_event:">
	Setting this flag to 1 will cause the reception
	<vspace blankLines="0"/>
	of SCTP_SNDRCV information on a per-message basis.  The
      application will need to use the recvmsg() interface so that it
      can receive the event information contained in the msg_control
      field.  Setting the flag to 0 will disable the reception of the
      message control information.  Note that this flag is not really a
      notification and is stored in the ancillary data (msg_control),
      not in the data part (msg_iov).
	</t>

	<t hangText="sctp_association_event:">
	Setting this flag to 1 will enable the
	<vspace blankLines="0"/>
	reception of association event notifications.  Setting the flag to
      0 will disable association event notifications.
	</t>

	<t hangText="sctp_address_event:">
	Setting this flag to 1 will enable the reception
	<vspace blankLines="0"/>
	of address event notifications.  Setting the flag to 0 will
      disable address event notifications.
	</t>

	<t hangText="sctp_send_failure_event:">
	Setting this flag to 1 will enable the
	<vspace blankLines="0"/>
	reception of send failure event notifications.  Setting the flag
      to 0 will disable send failure event notifications.
	</t>

	<t hangText="sctp_peer_error_event:">
	Setting this flag to 1 will enable the
	<vspace blankLines="0"/>
	reception of peer error event notifications.  Setting the flag to
      0 will disable peer error event notifications.
	</t>

	<t hangText="sctp_shutdown_event:">
	Setting this flag to 1 will enable the
	<vspace blankLines="0"/>
	reception of shutdown event notifications.  Setting the flag to 0
      will disable shutdown event notifications.
	</t>

	<t hangText="sctp_partial_delivery_event:">
	Setting this flag to 1 will enable the
	<vspace blankLines="0"/>
	reception of partial delivery event notifications.  Setting the
      flag to 0 will disable partial delivery event notifications.
	</t>

	<t hangText="sctp_adaptation_layer_event:">
	Setting this flag to 1 will enable the
	<vspace blankLines="0"/>
	reception of adaptation layer event notifications.  Setting the
      flag to 0 will disable adaptation layer event notifications.
	</t>

	<t hangText="sctp_authentication_event:">
	Setting this flag to 1 will enable the
	<vspace blankLines="0"/>
	reception of authentication layer event notifications.  Setting
      the flag to 0 will disable authentication layer event
      notifications.
	</t>

	<t hangText="sctp_sender_dry_event:">
	Setting this flag to 1 will enable the
	<vspace blankLines="0"/>
	reception of sender dry event notifications.  Setting the flag to
      0 will disable sender dry event notifications.
	</t>

	</list>
	</t>

	<t>
   An example where an application would like to receive data_io_events
   and association_events but no others would be as follows:</t>

	<figure><artwork><![CDATA[
{
  struct sctp_event_subscribe events;

  memset(&events, 0, sizeof(events));

  events.sctp_data_io_event = 1;
  events.sctp_association_event = 1;
]]></artwork>
	</figure>
	<figure><artwork><![CDATA[
  setsockopt(sd, IPPROTO_SCTP, SCTP_EVENTS, &events, sizeof(events));
}
]]></artwork>
	</figure>
	<t>
   Note that for one-to-many style SCTP sockets, the caller of recvmsg()
   receives ancillary data and notifications for all associations bound
   to the file descriptor.  For one-to-one style SCTP sockets, the
   caller receives ancillary data and notifications only for the single
   association bound to the file descriptor.</t>

	<t>
   By default, both the one-to-one style and the one-to-many style
   socket do not subscribe to any notification.</t>

	</section>

	<section title="SCTP_EVENT Option" anchor="section-6.2.2"><t>
   The SCTP_EVENTS socket option has one issue for future compatibility.
   As new features are added, the structure (sctp_event_subscribe) must
   be expanded.  This can cause an application binary interface (ABI)
   issue unless an implementation has added padding at the end of the
   structure.  To avoid this problem, SCTP_EVENTS has been deprecated
   and a new socket option SCTP_EVENT has taken its place.  The option
   is used with the following structure:</t>

	<figure><artwork><![CDATA[
struct sctp_event {
        sctp_assoc_t se_assoc_id;
        uint16_t     se_type;
        uint8_t      se_on;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="se_assoc_id:">
	The se_assoc_id field is ignored for one-to-one style
	<vspace blankLines="0"/>
	sockets.  For one-to-many style sockets, this field can be a
      particular association identifier or SCTP_{FUTURE|CURRENT|
      ALL}_ASSOC.
	</t>

	<t hangText="se_type:">
	The se_type field can be filled with any value that would
	<vspace blankLines="0"/>
	show up in the respective sn_type field (in the sctp_tlv structure
      of the notification).
	</t>

	<t hangText="se_on:">
	The se_on field is set to 1 to turn on an event and set to 0
	<vspace blankLines="0"/>
	to turn off an event.
	</t>

	</list>
	</t>

	<t>
   To use this option, the user fills in this structure and then calls
   setsockopt() to turn on or off an individual event.  The following is
   an example use of this option:</t>

	<figure><artwork><![CDATA[
{
  struct sctp_event event;

  memset(&event, 0, sizeof(event));

  event.se_assoc_id = SCTP_FUTURE_ASSOC;
  event.se_type = SCTP_SENDER_DRY_EVENT;
  event.se_on = 1;
  setsockopt(sd, IPPROTO_SCTP, SCTP_EVENT, &event, sizeof(event));
}
]]></artwork>
	</figure>
	<t>
   By default, both the one-to-one style and the one-to-many style
   socket do not subscribe to any notification.</t>

	</section>

	</section>

	</section>

	<section title="Common Operations for Both Styles" anchor="section-7"><section title="send(), recv(), sendto(), and recvfrom()" anchor="section-7.1"><t>
   Applications can use send() and sendto() to transmit data to the peer
   of an SCTP endpoint.  recv() and recvfrom() can be used to receive
   data from the peer.</t>

	<t>
   The function prototypes are</t>

	<t><list style="hanging" hangIndent="13"><t hangText="ssize_t send(int sd,">
	<vspace blankLines="0"/>
	const void *msg,
                size_t len,
                int flags);
	</t>

	<t hangText="ssize_t sendto(int sd,">
	<vspace blankLines="0"/>
	const void *msg,
                  size_t len,
                  int flags,
                  const struct sockaddr *to,
                  socklen_t tolen);
	</t>

	<t hangText="ssize_t recv(int sd,">
	<vspace blankLines="0"/>
	void *buf,
                size_t len,
                int flags);
	</t>

	<t hangText="ssize_t recvfrom(int sd,">
	<vspace blankLines="0"/>
	void *buf,
                    size_t len,
                    int flags,
                    struct sockaddr *from,
                    socklen_t *fromlen);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor of an SCTP endpoint.
	<vspace blankLines="0"/>
	</t>

	<t hangText="msg:">
	The message to be sent.
	<vspace blankLines="0"/>
	</t>

	<t hangText="len:">
	The size of the message or the size of the buffer.
	<vspace blankLines="0"/>
	</t>

	<t hangText="to:">
	One of the peer addresses of the association to be used to send
	<vspace blankLines="0"/>
	the message.
	</t>

	<t hangText="tolen:">
	The size of the address.
	<vspace blankLines="0"/>
	</t>

	<t hangText="buf:">
	The buffer to store a received message.
	<vspace blankLines="0"/>
	</t>

	<t hangText="from:">
	The buffer to store the peer address used to send the received
	<vspace blankLines="0"/>
	message.
	</t>

	<t hangText="fromlen:">
	The size of the from address.
	<vspace blankLines="0"/>
	</t>

	<t hangText="flags:">
	(described below).
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<t>
   These calls give access to only basic SCTP protocol features.  If
   either peer in the association uses multiple streams, or sends
   unordered data, these calls will usually be inadequate and may
   deliver the data in unpredictable ways.</t>

	<t>
   SCTP has the concept of multiple streams in one association.  The
   above calls do not allow the caller to specify on which stream a
   message should be sent.  The system uses stream 0 as the default
   stream for send() and sendto().  recv() and recvfrom() return data
   from any stream, but the caller cannot distinguish the different
   streams.  This may result in data seeming to arrive out of order.
   Similarly, if a DATA chunk is sent unordered, recv() and recvfrom()
   provide no indication.</t>

	<t>
   SCTP is message based.  The msg buffer above in send() and sendto()
   is considered to be a single message.  This means that if the caller
   wants to send a message that is composed by several buffers, the
   caller needs to combine them before calling send() or sendto().
   Alternately, the caller can use sendmsg() to do that without
   combining them.  Sending a message using send() or sendto() is atomic
   unless explicit EOR marking is enabled on the socket specified by sd.
   Using sendto() on a non-connected one-to-one style socket for
   implicit connection setup may or may not work, depending on the SCTP
   implementation.  recv() and recvfrom() cannot distinguish message
   boundaries (i.e., there is no way to observe the MSG_EOR flag to
   detect partial delivery).</t>

	<t>
   When receiving, if the buffer supplied is not large enough to hold a
   complete message, the receive call acts like a stream socket and
   returns as much data as will fit in the buffer.</t>

	<t>
   Note that the send() and recv() calls may not be used for a one-to-
   many style socket.</t>

	<t>
   Note that if an application calls a send() or sendto() function with
   no user data, the SCTP implementation should reject the request with
   an appropriate error message.  An implementation is not allowed to
   send a DATA chunk with no user data <xref target="RFC4960"/>.</t>

	</section>

	<section title="setsockopt() and getsockopt()" anchor="section-7.2"><t>
   Applications use setsockopt() and getsockopt() to set or retrieve
   socket options.  Socket options are used to change the default
   behavior of socket calls.  They are described in <xref target="section-8"/>.</t>

	<t>
   The function prototypes are</t>

	<t><list style="hanging" hangIndent="15"><t hangText="int getsockopt(int sd,">
	<vspace blankLines="0"/>
	int level,
                  int optname,
                  void *optval,
                  socklen_t *optlen);
	</t>

	</list>
	</t>

	<t>
   and</t>

	<t><list style="hanging" hangIndent="15"><t hangText="int setsockopt(int sd,">
	<vspace blankLines="0"/>
	int level,
                  int optname,
                  const void *optval,
                  socklen_t optlen);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor.
	<vspace blankLines="0"/>
	</t>

	<t hangText="level:">
	Set to IPPROTO_SCTP for all SCTP options.
	<vspace blankLines="0"/>
	</t>

	<t hangText="optname:">
	The option name.
	<vspace blankLines="0"/>
	</t>

	<t hangText="optval:">
	The buffer to store the value of the option.
	<vspace blankLines="0"/>
	</t>

	<t hangText="optlen:">
	The size of the buffer (or the length of the option
	<vspace blankLines="0"/>
	returned).
	</t>

	</list>
	</t>

	<t>
   These functions return 0 on success and -1 in case of an error.</t>

	<t>
   All socket options set on a one-to-one style listening socket also
   apply to all future accepted sockets.  For one-to-many style sockets,
   often a socket option will pass a structure that includes an assoc_id
   field.  This field can be filled with the association identifier of a
   particular association and unless otherwise specified can be filled
   with one of the following constants:</t>

	<t><list style="hanging" hangIndent="3"><t hangText="SCTP_FUTURE_ASSOC:">
	Specifies that only future associations created
	<vspace blankLines="0"/>
	after this socket option will be affected by this call.
	</t>

	<t hangText="SCTP_CURRENT_ASSOC:">
	Specifies that only currently existing
	<vspace blankLines="0"/>
	associations will be affected by this call, and future
      associations will still receive the previous default value.
	</t>

	<t hangText="SCTP_ALL_ASSOC:">
	Specifies that all current and future associations
	<vspace blankLines="0"/>
	will be affected by this call.
	</t>

	</list>
	</t>

	</section>

	<section title="read() and write()" anchor="section-7.3"><t>
   Applications can use read() and write() to receive and send data from
   and to a peer.  They have the same semantics as recv() and send(),
   except that the flags parameter cannot be used.</t>

	</section>

	<section title="getsockname()" anchor="section-7.4"><t>
   Applications use getsockname() to retrieve the locally bound socket
   address of the specified socket.  This is especially useful if the
   caller let SCTP choose a local port.  This call is for single-homed
   endpoints.  It does not work well with multi-homed endpoints.  See
   <xref target="section-9.5"/> for a multi-homed version of the call.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="16"><t hangText="int getsockname(int sd,">
	<vspace blankLines="0"/>
	struct sockaddr *address,
                   socklen_t *len);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor to be queried.
	<vspace blankLines="0"/>
	</t>

	<t hangText="address:">
	On return, one locally bound address (chosen by the SCTP
	<vspace blankLines="0"/>
	stack) is stored in this buffer.  If the socket is an IPv4 socket,
      the address will be IPv4.  If the socket is an IPv6 socket, the
      address will be either an IPv6 or IPv4 address.
	</t>

	<t hangText="len:">
	The caller should set the length of the address here.  On
	<vspace blankLines="0"/>
	return, this is set to the length of the returned address.
	</t>

	</list>
	</t>

	<t>
   getsockname() returns 0 on success and -1 in case of an error.</t>

	<t>
   If the actual length of the address is greater than the length of the
   supplied sockaddr structure, the stored address will be truncated.</t>

	<t>
   If the socket has not been bound to a local name, the value stored in
   the object pointed to by address is unspecified.</t>

	</section>

	<section title="Implicit Association Setup" anchor="section-7.5"><t>
   The application can begin sending and receiving data using the
   sendmsg()/recvmsg() or sendto()/recvfrom() calls, without going
   through any explicit association setup procedures (i.e., no connect()
   calls required).</t>

	<t>
   Whenever sendmsg() or sendto() is called and the SCTP stack at the
   sender finds that no association exists between the sender and the
   intended receiver (identified by the address passed either in the
   msg_name field of the msghdr structure in the sendmsg() call or the
   dest_addr field in the sendto() call), the SCTP stack will
   automatically set up an association to the intended receiver.</t>

	<t>
   Upon successful association setup, an SCTP_COMM_UP notification will
   be dispatched to the socket at both the sender and receiver side.
   This notification can be read by the recvmsg() system call (see
   <xref target="section-3.1.4"/>).</t>

	<t>
   Note that if the SCTP stack at the sender side supports bundling, the
   first user message may be bundled with the COOKIE ECHO message
   <xref target="RFC4960"/>.</t>

	<t>
   When the SCTP stack sets up a new association implicitly, the
   SCTP_INIT type ancillary data may also be passed along (see
   <xref target="section-5.3.1"/> for details of the data structures) to change some
   parameters used in setting up a new association.</t>

	<t>
   If this information is not present in the sendmsg() call, or if the
   implicit association setup is triggered by a sendto() call, the
   default association initialization parameters will be used.  These
   default association parameters may be set with respective
   setsockopt() calls or be left to the system defaults.</t>

	<t>
   Implicit association setup cannot be initiated by send() calls.</t>

	</section>

	</section>

	<section title="Socket Options" anchor="section-8"><t>
   The following subsection describes various SCTP-level socket options
   that are common to both styles.  SCTP associations can be
   multi-homed.  Therefore, certain option parameters include a
   sockaddr_storage structure to select to which peer address the option
   should be applied.</t>

	<t>
   For the one-to-many style sockets, an sctp_assoc_t (association
   identifier) parameter is used to identify the association instance
   that the operation affects.  So it must be set when using this style.</t>

	<t>
   For the one-to-one style sockets and branched-off one-to-many style
   sockets (see <xref target="section-9.2"/>), this association ID parameter is ignored.</t>

	<t>
   Note that socket- or IP-level options are set or retrieved per
   socket.  This means that for one-to-many style sockets, the options
   will be applied to all associations (similar to using SCTP_ALL_ASSOC
   as the association identifier) belonging to the socket.  For the one-
   to-one style, these options will be applied to all peer addresses of
   the association controlled by the socket.  Applications should be
   careful in setting those options.</t>

	<t>
   For some IP stacks, getsockopt() is read-only, so a new interface
   will be needed when information must be passed both into and out of
   the SCTP stack.  The syntax for sctp_opt_info() is</t>

	<t><list style="hanging" hangIndent="18"><t hangText="int sctp_opt_info(int sd,">
	<vspace blankLines="0"/>
	sctp_assoc_t id,
                     int opt,
                     void *arg,
                     socklen_t *size);
	</t>

	</list>
	</t>

	<t>
   The sctp_opt_info() call is a replacement for getsockopt() only and
   will not set any options associated with the specified socket.  A
   setsockopt() call must be used to set any writable option.</t>

	<t>
   For one-to-many style sockets, id specifies the association to query.
   For one-to-one style sockets, id is ignored.  For one-to-many style
   sockets, any association identifier in the structure provided as arg
   is ignored, and id takes precedence.</t>

	<t>
   Note that SCTP_CURRENT_ASSOC and SCTP_ALL_ASSOC cannot be used with
   sctp_opt_info() or in getsockopt() calls.  Using them will result in
   an error (returning -1 and errno set to EINVAL).  SCTP_FUTURE_ASSOC
   can be used to query information for future associations.</t>

	<t>
   The field opt specifies which SCTP socket option to get.  It can get
   any socket option currently supported that requests information
   (either read/write options or read-only) such as</t>

	<t>
   SCTP_RTOINFO</t>

	<t>
   SCTP_ASSOCINFO</t>

	<t>
   SCTP_PRIMARY_ADDR</t>

	<t>
   SCTP_PEER_ADDR_PARAMS</t>

	<t>
   SCTP_DEFAULT_SEND_PARAM</t>

	<t>
   SCTP_MAX_SEG</t>

	<t>
   SCTP_AUTH_ACTIVE_KEY</t>

	<t>
   SCTP_DELAYED_SACK</t>

	<t>
   SCTP_MAX_BURST</t>

	<t>
   SCTP_CONTEXT</t>

	<t>
   SCTP_EVENT</t>

	<t>
   SCTP_DEFAULT_SNDINFO</t>

	<t>
   SCTP_DEFAULT_PRINFO</t>

	<t>
   SCTP_STATUS</t>

	<t>
   SCTP_GET_PEER_ADDR_INFO</t>

	<t>
   SCTP_PEER_AUTH_CHUNKS</t>

	<t>
   SCTP_LOCAL_AUTH_CHUNKS</t>

	<t>
   The arg field is an option-specific structure buffer provided by the
   caller.  See the rest of this section for more information on these
   options and option-specific structures.</t>

	<t>
   sctp_opt_info() returns 0 on success, or on failure returns -1 and
   sets errno to the appropriate error code.</t>

	<section title="Read/Write Options" anchor="section-8.1"><section title="Retransmission Timeout Parameters (SCTP_RTOINFO)" anchor="section-8.1.1"><t>
   The protocol parameters used to initialize and limit the
   retransmission timeout (RTO) are tunable.  See <xref target="RFC4960"/> for more
   information on how these parameters are used in RTO calculation.</t>

	<t>
   The following structure is used to access and modify these
   parameters:</t>

	<figure><artwork><![CDATA[
struct sctp_rtoinfo {
  sctp_assoc_t srto_assoc_id;
  uint32_t srto_initial;
  uint32_t srto_max;
  uint32_t srto_min;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="srto_assoc_id:">
	This parameter is ignored for one-to-one style
	<vspace blankLines="0"/>
	sockets.  For one-to-many style sockets, the application may fill
      in an association identifier or SCTP_FUTURE_ASSOC.  It is an error
      to use SCTP_{CURRENT|ALL}_ASSOC in srto_assoc_id.
	</t>

	<t hangText="srto_initial:">
	This parameter contains the initial RTO value.
	<vspace blankLines="0"/>
	</t>

	<t hangText="srto_max and srto_min:">
	These parameters contain the maximum and
	<vspace blankLines="0"/>
	minimum bounds for all RTOs.
	</t>

	</list>
	</t>

	<t>
   All times are given in milliseconds.  A value of 0, when modifying
   the parameters, indicates that the current value should not be
   changed.</t>

	<t>
   To access or modify these parameters, the application should call
   getsockopt() or setsockopt(), respectively, with the option name
   SCTP_RTOINFO.</t>

	</section>

	<section title="Association Parameters (SCTP_ASSOCINFO)" anchor="section-8.1.2"><t>
   This option is used to both examine and set various association and
   endpoint parameters.  See <xref target="RFC4960"/> for more information on how these
   parameters are used.</t>

	<t>
   The following structure is used to access and modify these
   parameters:</t>

	<figure><artwork><![CDATA[
struct sctp_assocparams {
  sctp_assoc_t sasoc_assoc_id;
  uint16_t sasoc_asocmaxrxt;
  uint16_t sasoc_number_peer_destinations;
  uint32_t sasoc_peer_rwnd;
  uint32_t sasoc_local_rwnd;
  uint32_t sasoc_cookie_life;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="sasoc_assoc_id:">
	This parameter is ignored for one-to-one style
	<vspace blankLines="0"/>
	sockets.  For one-to-many style sockets, the application may fill
      in an association identifier or SCTP_FUTURE_ASSOC.  It is an error
      to use SCTP_{CURRENT|ALL}_ASSOC in sasoc_assoc_id.
	</t>

	<t hangText="sasoc_asocmaxrxt:">
	This parameter contains the maximum retransmission
	<vspace blankLines="0"/>
	attempts to make for the association.
	</t>

	<t hangText="sasoc_number_peer_destinations:">
	This parameter is the number of
	<vspace blankLines="0"/>
	destination addresses that the peer has.
	</t>

	<t hangText="sasoc_peer_rwnd:">
	This parameter holds the current value of the
	<vspace blankLines="0"/>
	peer's rwnd (reported in the last selective acknowledgment (SACK))
      minus any outstanding data (i.e., data in flight).
	</t>

	<t hangText="sasoc_local_rwnd:">
	This parameter holds the last reported rwnd that
	<vspace blankLines="0"/>
	was sent to the peer.
	</t>

	<t hangText="sasoc_cookie_life:">
	This parameter is the association's cookie life
	<vspace blankLines="0"/>
	value used when issuing cookies.
	</t>

	</list>
	</t>

	<t>
   The value of sasoc_peer_rwnd is meaningless when examining endpoint
   information (i.e., it is only valid when examining information on a
   specific association).</t>

	<t>
   All time values are given in milliseconds.  A value of 0, when
   modifying the parameters, indicates that the current value should not
   be changed.</t>

	<t>
   The values of sasoc_asocmaxrxt and sasoc_cookie_life may be set on
   either an endpoint or association basis.  The rwnd and destination
   counts (sasoc_number_peer_destinations, sasoc_peer_rwnd,
   sasoc_local_rwnd) are not settable, and any value placed in these is
   ignored.</t>

	<t>
   To access or modify these parameters, the application should call
   getsockopt() or setsockopt(), respectively, with the option name
   SCTP_ASSOCINFO.</t>

	<t>
   The maximum number of retransmissions before an address is considered
   unreachable is also tunable, but is address-specific, so it is
   covered in a separate option.  If an application attempts to set the
   value of the association's maximum retransmission parameter to more
   than the sum of all maximum retransmission parameters, setsockopt()
   may return an error.  The reason for this, from Section 8.2 of
   <xref target="RFC4960"/>, is as follows:</t>

	<t><list hangIndent="3" style="hanging"><t>
      Note: When configuring the SCTP endpoint, the user should avoid
      having the value of 'Association.Max.Retrans' (sasoc_maxrxt in
      this option) larger than the summation of the 'Path.Max.Retrans'
      (see spp_pathmaxrxt in <xref target="section-8.1.12"/>) of all of the destination
      addresses for the remote endpoint.  Otherwise, all of the
      destination addresses may become inactive while the endpoint still
      considers the peer endpoint reachable.</t>

	</list>
	</t>

	</section>

	<section title="Initialization Parameters (SCTP_INITMSG)" anchor="section-8.1.3"><t>
   Applications can specify protocol parameters for the default
   association initialization.  The structure used to access and modify
   these parameters is defined in <xref target="section-5.3.1"/>.  The option name
   argument to setsockopt() and getsockopt() is SCTP_INITMSG.</t>

	<t>
   Setting initialization parameters is effective only on an unconnected
   socket (for one-to-many style sockets, only future associations are
   affected by the change).</t>

	</section>

	<section title="SO_LINGER" anchor="section-8.1.4"><t>
   An application can use this option to perform the SCTP ABORT
   primitive.  This option affects all associations related to the
   socket.</t>

	<t>
   The linger option structure is</t>

	<figure><artwork><![CDATA[
struct linger {
  int l_onoff;  /* option on/off */
  int l_linger; /* linger time   */
};
]]></artwork>
	</figure>
	<t>
   To enable the option, set l_onoff to 1.  If the l_linger value is set
   to 0, calling close() is the same as the ABORT primitive.  If the
   value is set to a negative value, the setsockopt() call will return
   an error.  If the value is set to a positive value linger_time, the
   close() can be blocked for at most linger_time.  Please note that the
   time unit is in seconds, according to POSIX, but might be different
   on specific platforms.  If the graceful shutdown phase does not
   finish during this period, close() will return, but the graceful
   shutdown phase will continue in the system.</t>

	<t>
   Note that this is a socket-level option, not an SCTP-level option.
   When using this option, an application must specify a level of
   SOL_SOCKET in the call.</t>

	</section>

	<section title="SCTP_NODELAY" anchor="section-8.1.5"><t>
   This option turns on/off any Nagle-like algorithm.  This means that
   packets are generally sent as soon as possible, and no unnecessary
   delays are introduced, at the cost of more packets in the network.
   In particular, not using any Nagle-like algorithm might reduce the
   bundling of small user messages in cases where this would require an
   additional delay.</t>

	<t>
   Turning this option on disables any Nagle-like algorithm.</t>

	<t>
   This option expects an integer boolean flag, where a non-zero value
   turns on the option, and a zero value turns off the option.</t>

	</section>

	<section title="SO_RCVBUF" anchor="section-8.1.6"><t>
   This option sets the receive buffer size in octets.  For SCTP one-to-
   one style sockets, this option controls the receiver window size.
   For one-to-many style sockets, the meaning is implementation
   dependent.  It might control the receive buffer for each association
   bound to the socket descriptor, or it might control the receive
   buffer for the whole socket.  This option expects an integer.</t>

	<t>
   Note that this is a socket-level option, not an SCTP-level option.
   When using this option, an application must specify a level of
   SOL_SOCKET in the call.</t>

	</section>

	<section title="SO_SNDBUF" anchor="section-8.1.7"><t>
   This option sets the send buffer size.  For SCTP one-to-one style
   sockets, this option controls the amount of data SCTP may have
   waiting in internal buffers to be sent.  This option therefore bounds
   the maximum size of data that can be sent in a single send call.  For
   one-to-many style sockets, the effect is the same, except that it
   applies to one or all associations (see <xref target="section-3.3"/>) bound to the
   socket descriptor used in the setsockopt() or getsockopt() call.  The
   option applies to each association's window size separately.  This
   option expects an integer.</t>

	<t>
   Note that this is a socket-level option, not an SCTP-level option.
   When using this option, an application must specify a level of
   SOL_SOCKET in the call.</t>

	</section>

	<section title="Automatic Close of Associations (SCTP_AUTOCLOSE)" anchor="section-8.1.8"><t>
   This socket option is applicable to the one-to-many style socket
   only.  When set, it will cause associations that are idle for more
   than the specified number of seconds to automatically close using the
   graceful shutdown procedure.  An idle association is defined as an
   association that has not sent or received user data.  The special
   value of '0' indicates that no automatic close of any association
   should be performed; this is the default value.  This option expects
   an integer defining the number of seconds of idle time before an
   association is closed.</t>

	<t>
   An application using this option should enable the ability to receive
   the association change notification.  This is the only mechanism by
   which an application is informed about the closing of an association.
   After an association is closed, the association identifier assigned
   to it can be reused.  An application should be aware of this to avoid
   the possible problem of sending data to an incorrect peer endpoint.</t>

	</section>

	<section title="Set Primary Address (SCTP_PRIMARY_ADDR)" anchor="section-8.1.9"><t>
   This option requests that the local SCTP stack uses the enclosed peer
   address as the association's primary.  The enclosed address must be
   one of the association peer's addresses.</t>

	<t>
   The following structure is used to make a set peer primary request:</t>

	<figure><artwork><![CDATA[
struct sctp_setprim {
  sctp_assoc_t ssp_assoc_id;
  struct sockaddr_storage ssp_addr;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="ssp_assoc_id:">
	This parameter is ignored for one-to-one style
	<vspace blankLines="0"/>
	sockets.  For one-to-many style sockets, it identifies the
      association for this request.  Note that the special sctp_assoc_t
      SCTP_{FUTURE|ALL|CURRENT}_ASSOC are not allowed.
	</t>

	<t hangText="ssp_addr:">
	This parameter is the address to set as primary.  No
	<vspace blankLines="0"/>
	wildcard address is allowed.
	</t>

	</list>
	</t>

	</section>

	<section title="Set Adaptation Layer Indicator (SCTP_ADAPTATION_LAYER)" anchor="section-8.1.10"><t>
   This option requests that the local endpoint set the specified
   Adaptation Layer Indication parameter for all future INIT and
   INIT-ACK exchanges.</t>

	<t>
   The following structure is used to access and modify this parameter:</t>

	<figure><artwork><![CDATA[
struct sctp_setadaptation {
  uint32_t   ssb_adaptation_ind;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="ssb_adaptation_ind:">
	The adaptation layer indicator that will be
	<vspace blankLines="0"/>
	included in any outgoing Adaptation Layer Indication parameter.
	</t>

	</list>
	</t>

	</section>

	<section title="Enable/Disable Message Fragmentation (SCTP_DISABLE_FRAGMENTS)" anchor="section-8.1.11"><t>
   This option is an on/off flag and is passed as an integer, where a
   non-zero is on and a zero is off.  If enabled, no SCTP message
   fragmentation will be performed.  The effect of enabling this option
   is that if a message being sent exceeds the current Path MTU (PMTU)
   size, the message will not be sent and instead an error will be
   indicated to the user.  If this option is disabled (the default),
   then a message exceeding the size of the PMTU will be fragmented and
   reassembled by the peer.</t>

	</section>

	<section title="Peer Address Parameters (SCTP_PEER_ADDR_PARAMS)" anchor="section-8.1.12"><t>
   Applications can enable or disable heartbeats for any peer address of
   an association, modify an address's heartbeat interval, force a
   heartbeat to be sent immediately, and adjust the address's maximum
   number of retransmissions sent before an address is considered
   unreachable.</t>

	<t>
   The following structure is used to access and modify an address's
   parameters:</t>

	<figure><artwork><![CDATA[
struct sctp_paddrparams {
  sctp_assoc_t spp_assoc_id;
  struct sockaddr_storage spp_address;
  uint32_t spp_hbinterval;
  uint16_t spp_pathmaxrxt;
  uint32_t spp_pathmtu;
  uint32_t spp_flags;
  uint32_t spp_ipv6_flowlabel;
  uint8_t  spp_dscp;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="spp_assoc_id:">
	This parameter is ignored for one-to-one style
	<vspace blankLines="0"/>
	sockets.  For one-to-many style sockets, the application may fill
      in an association identifier or SCTP_FUTURE_ASSOC for this query.
      It is an error to use SCTP_{CURRENT|ALL}_ASSOC in spp_assoc_id.
	</t>

	<t hangText="spp_address:">
	This specifies which address is of interest.  If a
	<vspace blankLines="0"/>
	wildcard address is provided, it applies to all current and future
      paths.
	</t>

	<t hangText="spp_hbinterval:">
	This contains the value of the heartbeat interval,
	<vspace blankLines="0"/>
	in milliseconds (HB.Interval in <xref target="RFC4960"/>).  Note that unless the
      spp_flags field is set to SPP_HB_ENABLE, the value of this field
      is ignored.  Note also that a value of zero indicates that the
      current setting should be left unchanged.  To set an actual value
      of zero, the SPP_HB_TIME_IS_ZERO flag should be used.  Even when
      it is set to 0, it does not mean that SCTP will continuously send
      out heartbeats, since the actual interval also includes the
      current RTO and jitter (see Section 8.3 of <xref target="RFC4960"/>).
	</t>

	<t hangText="spp_pathmaxrxt:">
	This contains the maximum number of retransmissions
	<vspace blankLines="0"/>
	before this address shall be considered unreachable.  Note that a
      value of zero indicates that the current setting should be left
      unchanged.
	</t>

	<t hangText="spp_pathmtu:">
	This field contains the current Path MTU of the peer
	<vspace blankLines="0"/>
	address.  It is the number of bytes available in an SCTP packet
      for chunks.  Providing a value of 0 does not change the current
      setting.  If a positive value is provided and SPP_PMTUD_DISABLE is
      set in the spp_flags field, the given value is used as the Path
      MTU.  If SPP_PMTUD_ENABLE is set in the spp_flags field, the
      spp_pathmtu field is ignored.
	</t>

	<t hangText="spp_flags:">
	These flags are used to control various features on an
	<vspace blankLines="0"/>
	association.  The flag field is a bitmask that may contain zero or
      more of the following options:
	<list style="hanging" hangIndent="3"><t hangText="SPP_HB_ENABLE:">
	This field enables heartbeats on the specified
	<vspace blankLines="0"/>
	address.
	</t>

	<t hangText="SPP_HB_DISABLE:">
	This field disables heartbeats on the specified
	<vspace blankLines="0"/>
	address.  Note that SPP_HB_ENABLE and SPP_HB_DISABLE are
         mutually exclusive; only one of these two should be specified.
         Enabling both fields will yield undetermined results.
	</t>

	<t hangText="SPP_HB_DEMAND:">
	This field requests that a user-initiated
	<vspace blankLines="0"/>
	heartbeat be made immediately.  This must not be used in
         conjunction with a wildcard address.
	</t>

	<t hangText="SPP_HB_TIME_IS_ZERO:">
	This field specifies that the time for
	<vspace blankLines="0"/>
	heartbeat delay is to be set to 0 milliseconds.
	</t>

	<t hangText="SPP_PMTUD_ENABLE:">
	This field will enable PMTU discovery on the
	<vspace blankLines="0"/>
	specified address.
	</t>

	<t hangText="SPP_PMTUD_DISABLE:">
	This field will disable PMTU discovery on the
	<vspace blankLines="0"/>
	specified address.  Note that if the address field is empty,
         then all addresses on the association are affected.  Note also
         that SPP_PMTUD_ENABLE and SPP_PMTUD_DISABLE are mutually
         exclusive.  Enabling both fields will yield undetermined
         results.
	</t>

	<t hangText="SPP_IPV6_FLOWLABEL:">
	Setting this flag enables the setting of the
	<vspace blankLines="0"/>
	IPV6 flow label value.  The value is contained in the
         spp_ipv6_flowlabel field.
	<vspace blankLines="1"/>
	Upon retrieval, this flag will be set to indicate that the
         spp_ipv6_flowlabel field has a valid value returned.  If a
         specific destination address is set (in the spp_address field),
         then the value returned is that of the address.  If just an
         association is specified (and no address), then the
         association's default flow label is returned.  If neither an
         association nor a destination is specified, then the socket's
         default flow label is returned.  For non-IPv6 sockets, this
         flag will be left cleared.
	</t>

	<t hangText="SPP_DSCP:">
	Setting this flag enables the setting of the
	<vspace blankLines="0"/>
	Differentiated Services Code Point (DSCP) value associated with
         either the association or a specific address.  The value is
         obtained in the spp_dscp field.
	<vspace blankLines="1"/>
	Upon retrieval, this flag will be set to indicate that the
         spp_dscp field has a valid value returned.  If a specific
         destination address is set when called (in the spp_address
         field), then that specific destination address's DSCP value is
         returned.  If just an association is specified, then the
         association's default DSCP is returned.  If neither an
         association nor a destination is specified, then the socket's
         default DSCP is returned.
	</t>

	</list>
	</t>

	<t hangText="spp_ipv6_flowlabel:">
	This field is used in conjunction with the
	<vspace blankLines="0"/>
	SPP_IPV6_FLOWLABEL flag and contains the IPv6 flow label.  The 20
      least significant bits are used for the flow label.  This setting
      has precedence over any IPv6-layer setting.
	</t>

	<t hangText="spp_dscp:">
	This field is used in conjunction with the SPP_DSCP flag
	<vspace blankLines="0"/>
	and contains the DSCP.  The 6 most significant bits are used for
      the DSCP.  This setting has precedence over any IPv4- or IPv6-
      layer setting.
	</t>

	</list>
	</t>

	<t>
   Please note that changing the flow label or DSCP value will affect
   all packets sent by the SCTP stack after setting these parameters.
   The flow label might also be set via the sin6_flowinfo field of the
   sockaddr_in6 structure.</t>

	</section>

	<section title="Set Default Send Parameters (SCTP_DEFAULT_SEND_PARAM) - DEPRECATED" anchor="section-8.1.13"><t>
   Please note that this option is deprecated.  SCTP_DEFAULT_SNDINFO
   (<xref target="section-8.1.31"/>) should be used instead.</t>

	<t>
   Applications that wish to use the sendto() system call may wish to
   specify a default set of parameters that would normally be supplied
   through the inclusion of ancillary data.  This socket option allows
   such an application to set the default sctp_sndrcvinfo structure.
   The application that wishes to use this socket option simply passes
   the sctp_sndrcvinfo structure (defined in <xref target="section-5.3.2"/>) to this
   call.  The input parameters accepted by this call include
   sinfo_stream, sinfo_flags, sinfo_ppid, sinfo_context, and
   sinfo_timetolive.  The sinfo_flags field is composed of a bitwise OR
   of SCTP_UNORDERED, SCTP_EOF, and SCTP_SENDALL.  The sinfo_assoc_id
   field specifies the association to which to apply the parameters.
   For a one-to-many style socket, any of the predefined constants are
   also allowed in this field.  The field is ignored for one-to-one
   style sockets.</t>

	</section>

	<section title="Set Notification and Ancillary Events (SCTP_EVENTS) - DEPRECATED" anchor="section-8.1.14"><t>
   This socket option is used to specify various notifications and
   ancillary data the user wishes to receive.  Please see <xref target="section-6.2.1"/>
   for a full description of this option and its usage.  Note that this
   option is considered deprecated and is present for backward
   compatibility.  New applications should use the SCTP_EVENT option.
   See <xref target="section-6.2.2"/> for a full description of that option as well.</t>

	</section>

	<section title="Set/Clear IPv4 Mapped Addresses (SCTP_I_WANT_MAPPED_V4_ADDR)" anchor="section-8.1.15"><t>
   This socket option is a boolean flag that turns on or off the mapping
   of IPv4 addresses.  If this option is turned on, then IPv4 addresses
   will be mapped to IPv6 representation.  If this option is turned off,
   then no mapping will be done of IPv4 addresses, and a user will
   receive both PF_INET6 and PF_INET type addresses on the socket.  See
   <xref target="RFC3542"/> for more details on mapped IPv6 addresses.</t>

	<t>
   If this socket option is used on a socket of type PF_INET, an error
   is returned.</t>

	<t>
   By default, this option is turned off and expects an integer to be
   passed where a non-zero value turns on the option and a zero value
   turns off the option.</t>

	</section>

	<section title="Get or Set the Maximum Fragmentation Size (SCTP_MAXSEG)" anchor="section-8.1.16"><t>
   This option will get or set the maximum size to put in any outgoing
   SCTP DATA chunk.  If a message is larger than this maximum size, it
   will be fragmented by SCTP into the specified size.  Note that the
   underlying SCTP implementation may fragment into smaller sized chunks
   when the PMTU of the underlying association is smaller than the value
   set by the user.  The default value for this option is '0', which
   indicates that the user is not limiting fragmentation and only the
   PMTU will affect SCTP's choice of DATA chunk size.  Note also that
   values set larger than the maximum size of an IP datagram will
   effectively let SCTP control fragmentation (i.e., the same as setting
   this option to 0).</t>

	<t>
   The following structure is used to access and modify this parameter:</t>

	<figure><artwork><![CDATA[
struct sctp_assoc_value {
  sctp_assoc_t assoc_id;
  uint32_t assoc_value;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="assoc_id:">
	This parameter is ignored for one-to-one style sockets.
	<vspace blankLines="0"/>
	For one-to-many style sockets, this parameter indicates upon which
      association the user is performing an action.  It is an error to
      use SCTP_{CURRENT|ALL}_ASSOC in assoc_id.
	</t>

	<t hangText="assoc_value:">
	This parameter specifies the maximum size in bytes.
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	</section>

	<section title="Get or Set the List of Supported HMAC Identifiers (SCTP_HMAC_IDENT)" anchor="section-8.1.17"><t>
   This option gets or sets the list of Hashed Message Authentication
   Code (HMAC) algorithms that the local endpoint requires the peer
   to use.</t>

	<t>
   The following structure is used to get or set these identifiers:</t>

	<figure><artwork><![CDATA[
struct sctp_hmacalgo {
  uint32_t shmac_number_of_idents;
  uint16_t shmac_idents[];
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="shmac_number_of_idents:">
	This field gives the number of elements
	<vspace blankLines="0"/>
	present in the array shmac_idents.
	</t>

	<t hangText="shmac_idents:">
	This parameter contains an array of HMAC identifiers
	<vspace blankLines="0"/>
	that the local endpoint is requesting the peer to use, in priority
      order.  The following identifiers are valid:
	<list style="symbols"><t>SCTP_AUTH_HMAC_ID_SHA1</t>

	<t>SCTP_AUTH_HMAC_ID_SHA256</t>

	</list>
	</t>

	</list>
	</t>

	<t>
   Note that the list supplied must include SCTP_AUTH_HMAC_ID_SHA1 and
   may include any of the other values in its preferred order (lowest
   list position has the highest preference in algorithm selection).</t>

	<t>
   Note also that the lack of SCTP_AUTH_HMAC_ID_SHA1, or the inclusion
   of an unknown HMAC identifier (including optional identifiers unknown
   to the implementation), will cause the set option to fail and return
   an error.</t>

	</section>

	<section title="Get or Set the Active Shared Key (SCTP_AUTH_ACTIVE_KEY)" anchor="section-8.1.18"><t>
   This option will get or set the active shared key to be used to build
   the association shared key.</t>

	<t>
   The following structure is used to access and modify these
   parameters:</t>

	<figure><artwork><![CDATA[
struct sctp_authkeyid {
  sctp_assoc_t scact_assoc_id;
  uint16_t scact_keynumber;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="scact_assoc_id:">
	This parameter sets the active key of the specified
	<vspace blankLines="0"/>
	association.  The special SCTP_{FUTURE|CURRENT|ALL}_ASSOC can be
      used.  For one-to-one style sockets, this parameter is ignored.
      Note, however, that this option will set the active key on the
      association if the socket is connected; otherwise, this option
      will set the default active key for the endpoint.
	</t>

	<t hangText="scact_keynumber:">
	This parameter is the shared key identifier that
	<vspace blankLines="0"/>
	the application is requesting to become the active shared key to
      be used for sending authenticated chunks.  The key identifier must
      correspond to an existing shared key.  Note that shared key
      identifier '0' defaults to a null key.
	</t>

	</list>
	</t>

	<t>
   When used with setsockopt(), the SCTP implementation must use the
   indicated shared key identifier for all messages being given to an
   SCTP implementation via a send call after the setsockopt() call,
   until changed again.  Therefore, the SCTP implementation must not
   bundle user messages that should be authenticated using different
   shared key identifiers.</t>

	<t>
   Initially, the key with key identifier 0 is the active key.</t>

	</section>

	<section title="Get or Set Delayed SACK Timer (SCTP_DELAYED_SACK)" anchor="section-8.1.19"><t>
   This option will affect the way delayed SACKs are performed.  This
   option allows the application to get or set the delayed SACK time, in
   milliseconds.  It also allows changing the delayed SACK frequency.
   Changing the frequency to 1 disables the delayed SACK algorithm.
   Note that if sack_delay or sack_freq is 0 when setting this option,
   the current values will remain unchanged.</t>

	<t>
   The following structure is used to access and modify these
   parameters:</t>

	<figure><artwork><![CDATA[
struct sctp_sack_info {
  sctp_assoc_t sack_assoc_id;
  uint32_t sack_delay;
  uint32_t sack_freq;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="sack_assoc_id:">
	This parameter is ignored for one-to-one style
	<vspace blankLines="0"/>
	sockets.  For one-to-many style sockets, this parameter indicates
      upon which association the user is performing an action.  The
      special SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be used.
	</t>

	<t hangText="sack_delay:">
	This parameter contains the number of milliseconds the
	<vspace blankLines="0"/>
	user is requesting that the delayed SACK timer be set to.  Note
      that this value is defined in <xref target="RFC4960"/> to be between 200 and 500
      milliseconds.
	</t>

	<t hangText="sack_freq:">
	This parameter contains the number of packets that must
	<vspace blankLines="0"/>
	be received before a SACK is sent without waiting for the delay
      timer to expire.  The default value is 2; setting this value to 1
      will disable the delayed SACK algorithm.
	</t>

	</list>
	</t>

	</section>

	<section title="Get or Set Fragmented Interleave (SCTP_FRAGMENT_INTERLEAVE)" anchor="section-8.1.20"><t>
   Fragmented interleave controls how the presentation of messages
   occurs for the message receiver.  There are three levels of fragment
   interleave defined.  Two of the levels affect one-to-one style
   sockets, while one-to-many style sockets are affected by all three
   levels.</t>

	<t>
   This option takes an integer value.  It can be set to a value of 0,
   1, or 2.  Attempting to set this level to other values will return an
   error.</t>

	<t>
   Setting the three levels provides the following receiver
   interactions:</t>

	<t><list style="hanging" hangIndent="3"><t hangText="level 0:">
	Prevents the interleaving of any messages.  This means that
	<vspace blankLines="0"/>
	when a partial delivery begins, no other messages will be received
      except the message being partially delivered.  If another message
      arrives on a different stream (or association) that could be
      delivered, it will be blocked waiting for the user to read all of
      the partially delivered message.
	</t>

	<t hangText="level 1:">
	Allows interleaving of messages that are from different
	<vspace blankLines="0"/>
	associations.  For one-to-one style sockets, level 0 and level 1
      thus have the same meaning, since a one-to-one style socket always
      receives messages from the same association.  Note that setting a
      one-to-many style socket to this level may cause multiple partial
      deliveries from different associations, but for any given
      association, only one message will be delivered until all parts of
      a message have been delivered.  This means that one large message,
      being read with an association identifier of "X", will block other
      messages from association "X" from being delivered.
	</t>

	<t hangText="level 2:">
	Allows complete interleaving of messages.  This level
	<vspace blankLines="0"/>
	requires that the sender not only carefully observe the peer
      association identifier (or address) but also pay careful attention
      to the stream number.  With this option enabled, a partially
      delivered message may begin being delivered for association "X"
      stream "Y", and the next subsequent receive may return a message
      from association "X" stream "Z".  Note that no other messages
      would be delivered for association "X" stream "Y" until all of
      stream "Y"'s partially delivered message was read.  Note that this
      option also affects one-to-one style sockets.  Also note that for
      one-to-many style sockets, not only another stream's message from
      the same association may be delivered upon the next receive, but
      some other association's message may also be delivered upon the
      next receive.
	</t>

	</list>
	</t>

	<t>
   An implementation should default one-to-many style sockets to level
   1, because otherwise, it is possible that a peer could begin sending
   a partial message and thus block all other peers from sending data.
   However, a setting of level 2 requires that the application not only
   be aware of the association (via the association identifier or peer's
   address) but also the stream number.  The stream number is not
   present unless the user has subscribed to the sctp_data_io_event (see
   <xref target="section-6.2"/>), which is deprecated, or has enabled the
   SCTP_RECVRCVINFO socket option (see <xref target="section-8.1.29"/>).  This is also
   why we recommend that one-to-one style sockets be defaulted to level
   0 (level 1 for one-to-one style sockets has no effect).  Note that an
   implementation should return an error if an application attempts to
   set the level to 2 and has not subscribed to the sctp_data_io_event
   event, which is deprecated, or has enabled the SCTP_RECVRCVINFO
   socket option.</t>

	<t>
   For applications that have subscribed to events, those events appear
   in the normal socket buffer data stream.  This means that unless the
   user has set the fragmentation interleave level to 0, notifications
   may also be interleaved with partially delivered messages.</t>

	</section>

	<section title="Set or Get the SCTP Partial Delivery Point (SCTP_PARTIAL_DELIVERY_POINT)" anchor="section-8.1.21"><t>
   This option will set or get the SCTP partial delivery point.  This
   point is the size of a message where the partial delivery API will be
   invoked to help free up rwnd space for the peer.  Setting this to a
   lower value will cause partial deliveries to happen more often.  This
   option expects an integer that sets or gets the partial delivery
   point in bytes.  Note also that the call will fail if the user
   attempts to set this value larger than the socket receive buffer
   size.</t>

	<t>
   Note that any single message having a length smaller than or equal to
   the SCTP partial delivery point will be delivered in a single read
   call as long as the user-provided buffer is large enough to hold the
   message.</t>

	</section>

	<section title="Set or Get the Use of Extended Receive Info (SCTP_USE_EXT_RCVINFO) - DEPRECATED" anchor="section-8.1.22"><t>
   This option will enable or disable the use of the extended version of
   the sctp_sndrcvinfo structure.  If this option is disabled, then the
   normal sctp_sndrcvinfo structure is returned in all receive message
   calls.  If this option is enabled, then the sctp_extrcvinfo structure
   is returned in all receive message calls.  The default is off.</t>

	<t>
   Note that the sctp_extrcvinfo structure is never used in any send
   call.</t>

	<t>
   This option is present for compatibility with older applications and
   is deprecated.  Future applications should use SCTP_NXTINFO to
   retrieve this same information via ancillary data.</t>

	</section>

	<section title="Set or Get the Auto ASCONF Flag (SCTP_AUTO_ASCONF)" anchor="section-8.1.23"><t>
   This option will enable or disable the use of the automatic
   generation of ASCONF chunks to add and delete addresses to an
   existing association.  Note that this option has two caveats, namely
   a) it only affects sockets that are bound to all addresses available
   to the SCTP stack, and b) the system administrator may have an
   overriding control that turns the ASCONF feature off no matter what
   setting the socket option may have.</t>

	<t>
   This option expects an integer boolean flag, where a non-zero value
   turns on the option, and a zero value turns off the option.</t>

	</section>

	<section title="Set or Get the Maximum Burst (SCTP_MAX_BURST)" anchor="section-8.1.24"><t>
   This option will allow a user to change the maximum burst of packets
   that can be emitted by this association.  Note that the default value
   is 4, and some implementations may restrict this setting so that it
   can only be lowered to positive values.</t>

	<t>
   To set or get this option, the user fills in the following structure:</t>

	<figure><artwork><![CDATA[
struct sctp_assoc_value {
  sctp_assoc_t assoc_id;
  uint32_t assoc_value;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="assoc_id:">
	This parameter is ignored for one-to-one style sockets.
	<vspace blankLines="0"/>
	For one-to-many style sockets, this parameter indicates upon which
      association the user is performing an action.  The special
      SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be used.
	</t>

	<t hangText="assoc_value:">
	This parameter contains the maximum burst.  Setting the
	<vspace blankLines="0"/>
	value to 0 disables burst mitigation.
	</t>

	</list>
	</t>

	</section>

	<section title="Set or Get the Default Context (SCTP_CONTEXT)" anchor="section-8.1.25"><t>
   The context field in the sctp_sndrcvinfo structure is normally only
   used when a failed message is retrieved holding the value that was
   sent down on the actual send call.  This option allows the setting,
   on an association basis, of a default context that will be received
   on reading messages from the peer.  This is especially helpful for an
   application when using one-to-many style sockets to keep some
   reference to an internal state machine that is processing messages on
   the association.  Note that the setting of this value only affects
   received messages from the peer and does not affect the value that is
   saved with outbound messages.</t>

	<t>
   To set or get this option, the user fills in the following structure:</t>

	<figure><artwork><![CDATA[
struct sctp_assoc_value {
  sctp_assoc_t assoc_id;
  uint32_t assoc_value;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="assoc_id:">
	This parameter is ignored for one-to-one style sockets.
	<vspace blankLines="0"/>
	For one-to-many style sockets, this parameter indicates upon which
      association the user is performing an action.  The special
      SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be used.
	</t>

	<t hangText="assoc_value:">
	This parameter contains the context.
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	</section>

	<section title="Enable or Disable Explicit EOR Marking (SCTP_EXPLICIT_EOR)" anchor="section-8.1.26"><t>
   This boolean flag is used to enable or disable explicit end of record
   (EOR) marking.  When this option is enabled, a user may make multiple
   send system calls to send a record and must indicate that they are
   finished sending a particular record by including the SCTP_EOR flag.
   If this boolean flag is disabled, then each individual send system
   call is considered to have an SCTP_EOR indicator set on it implicitly
   without the user having to explicitly add this flag.  The default
   is off.</t>

	<t>
   This option expects an integer boolean flag, where a non-zero value
   turns on the option, and a zero value turns off the option.</t>

	</section>

	<section title="Enable SCTP Port Reusage (SCTP_REUSE_PORT)" anchor="section-8.1.27"><t>
   This option only supports one-to-one style SCTP sockets.  If used on
   a one-to-many style SCTP socket, an error is indicated.</t>

	<t>
   This option expects an integer boolean flag, where a non-zero value
   turns on the option, and a zero value turns off the option.</t>

	<t>
   This socket option must not be used after calling bind() or
   sctp_bindx() for a one-to-one style SCTP socket.  If using bind() or
   sctp_bindx() on a socket with the SCTP_REUSE_PORT option, all other
   SCTP sockets bound to the same port must have set the SCTP_REUSE_PORT
   option.  Calling bind() or sctp_bindx() for a socket without having
   set the SCTP_REUSE_PORT option will fail if there are other sockets
   bound to the same port.  At most one socket being bound to the same
   port may be listening.</t>

	<t>
   It should be noted that the behavior of the socket-level socket
   option to reuse ports and/or addresses for SCTP sockets is
   unspecified.</t>

	</section>

	<section title="Set Notification Event (SCTP_EVENT)" anchor="section-8.1.28"><t>
   This socket option is used to set a specific notification option.
   Please see <xref target="section-6.2.2"/> for a full description of this option and
   its usage.</t>

	</section>

	<section title="Enable or Disable the Delivery of SCTP_RCVINFO as Ancillary Data (SCTP_RECVRCVINFO)" anchor="section-8.1.29"><t>
   Setting this option specifies that SCTP_RCVINFO (defined in
   <xref target="section-5.3.5"/>) is returned as ancillary data by recvmsg().</t>

	<t>
   This option expects an integer boolean flag, where a non-zero value
   turns on the option, and a zero value turns off the option.</t>

	</section>

	<section title="Enable or Disable the Delivery of SCTP_NXTINFO as Ancillary Data (SCTP_RECVNXTINFO)" anchor="section-8.1.30"><t>
   Setting this option specifies that SCTP_NXTINFO (defined in
   <xref target="section-5.3.6"/>) is returned as ancillary data by recvmsg().</t>

	<t>
   This option expects an integer boolean flag, where a non-zero value
   turns on the option, and a zero value turns off the option.</t>

	</section>

	<section title="Set Default Send Parameters (SCTP_DEFAULT_SNDINFO)" anchor="section-8.1.31"><t>
   Applications that wish to use the sendto() system call may wish to
   specify a default set of parameters that would normally be supplied
   through the inclusion of ancillary data.  This socket option allows
   such an application to set the default sctp_sndinfo structure.  The
   application that wishes to use this socket option simply passes the
   sctp_sndinfo structure (defined in <xref target="section-5.3.4"/>) to this call.  The
   input parameters accepted by this call include snd_sid, snd_flags,
   snd_ppid, and snd_context.  The snd_flags parameter is composed of a
   bitwise OR of SCTP_UNORDERED, SCTP_EOF, and SCTP_SENDALL.  The
   snd_assoc_id field specifies the association to which to apply the
   parameters.  For a one-to-many style socket, any of the predefined
   constants are also allowed in this field.  The field is ignored for
   one-to-one style sockets.</t>

	</section>

	<section title="Set Default PR-SCTP Parameters (SCTP_DEFAULT_PRINFO)" anchor="section-8.1.32"><t>
   This option sets and gets the default parameters for PR-SCTP.  They
   can be overwritten by specific information provided in send calls.</t>

	<t>
   The following structure is used to access and modify these
   parameters:</t>

	<figure><artwork><![CDATA[
struct sctp_default_prinfo {
  uint16_t pr_policy;
  uint32_t pr_value;
  sctp_assoc_t pr_assoc_id;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="pr_policy:">
	This field is the same as that described in
	<vspace blankLines="0"/>
	<xref target="section-5.3.7"/>.
	</t>

	<t hangText="pr_value:">
	This field is the same as that described in <xref target="section-5.3.7"/>.
	<vspace blankLines="0"/>
	</t>

	<t hangText="pr_assoc_id:">
	This field is ignored for one-to-one style sockets.
	<vspace blankLines="0"/>
	For one-to-many style sockets, pr_assoc_id can be a particular
      association identifier or SCTP_{FUTURE|CURRENT|ALL}_ASSOC.
	</t>

	</list>
	</t>

	</section>

	</section>

	<section title="Read-Only Options" anchor="section-8.2"><t>
   The options defined in this subsection are read-only.  Using this
   option in a setsockopt() call will result in an error indicating
   EOPNOTSUPP.</t>

	<section title="Association Status (SCTP_STATUS)" anchor="section-8.2.1"><t>
   Applications can retrieve current status information about an
   association, including association state, peer receiver window size,
   number of unacknowledged DATA chunks, and number of DATA chunks
   pending receipt.  This information is read-only.</t>

	<t>
   The following structure is used to access this information:</t>

	<figure><artwork><![CDATA[
struct sctp_status {
  sctp_assoc_t sstat_assoc_id;
  int32_t  sstat_state;
  uint32_t sstat_rwnd;
  uint16_t sstat_unackdata;
  uint16_t sstat_penddata;
  uint16_t sstat_instrms;
  uint16_t sstat_outstrms;
  uint32_t sstat_fragmentation_point;
  struct sctp_paddrinfo sstat_primary;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="sstat_assoc_id:">
	This parameter is ignored for one-to-one style
	<vspace blankLines="0"/>
	sockets.  For one-to-many style sockets, it holds the identifier
      for the association.  All notifications for a given association
      have the same association identifier.  The special SCTP_{FUTURE|
      CURRENT|ALL}_ASSOC cannot be used.
	</t>

	<t hangText="sstat_state:">
	This contains the association's current state, i.e.,
	<vspace blankLines="0"/>
	one of the following values:
	<list style="symbols"><t>SCTP_CLOSED</t>

	<t>SCTP_BOUND</t>

	<t>SCTP_LISTEN</t>

	<t>SCTP_COOKIE_WAIT</t>

	<t>SCTP_COOKIE_ECHOED</t>

	<t>SCTP_ESTABLISHED</t>

	<t>SCTP_SHUTDOWN_PENDING</t>

	<t>SCTP_SHUTDOWN_SENT</t>

	<t>SCTP_SHUTDOWN_RECEIVED</t>

	<t>SCTP_SHUTDOWN_ACK_SENT</t>

	</list>
	</t>

	<t hangText="sstat_rwnd:">
	This contains the association peer's current receiver
	<vspace blankLines="0"/>
	window size.
	</t>

	<t hangText="sstat_unackdata:">
	This is the number of unacknowledged DATA chunks.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sstat_penddata:">
	This is the number of DATA chunks pending receipt.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sstat_instrms:">
	This is the number of streams that the peer will be
	<vspace blankLines="0"/>
	using outbound.
	</t>

	<t hangText="sstat_outstrms:">
	This is the number of outbound streams that the
	<vspace blankLines="0"/>
	endpoint is allowed to use.
	</t>

	<t hangText="sstat_fragmentation_point:">
	This is the size at which SCTP
	<vspace blankLines="0"/>
	fragmentation will occur.
	</t>

	<t hangText="sstat_primary:">
	This is information on the current primary peer
	<vspace blankLines="0"/>
	address.
	</t>

	</list>
	</t>

	<t>
   To access these status values, the application calls getsockopt()
   with the option name SCTP_STATUS.</t>

	</section>

	<section title="Peer Address Information (SCTP_GET_PEER_ADDR_INFO)" anchor="section-8.2.2"><t>
   Applications can retrieve information about a specific peer address
   of an association, including its reachability state, congestion
   window, and retransmission timer values.  This information is
   read-only.</t>

	<t>
   The following structure is used to access this information:</t>

	<figure><artwork><![CDATA[
struct sctp_paddrinfo {
  sctp_assoc_t spinfo_assoc_id;
  struct sockaddr_storage spinfo_address;
  int32_t  spinfo_state;
  uint32_t spinfo_cwnd;
]]></artwork>
	</figure>
	<figure><artwork><![CDATA[
  uint32_t spinfo_srtt;
  uint32_t spinfo_rto;
  uint32_t spinfo_mtu;
};

spinfo_assoc_id:  This parameter is ignored for one-to-one style
   sockets.

   For one-to-many style sockets, this field may be filled by the
   application, and if so, this field will have priority in looking
   up the association instead of using the address specified in
   spinfo_address.  Note that if the address does not belong to the
   association specified, then this call will fail.  If the
   application does not fill in the spinfo_assoc_id, then the address
   will be used to look up the association, and on return, this field
   will have the valid association identifier.  In other words, this
   call can be used to translate an address into an association
   identifier.  Note that the predefined constants are not allowed
   for this option.

spinfo_address:  This is filled by the application and contains the
   peer address of interest.

spinfo_state:  This contains the peer address's state:

   SCTP_UNCONFIRMED:  This is the initial state of a peer address.

   SCTP_ACTIVE:  This state is entered the first time after path
      verification.  It can also be entered if the state is
      SCTP_INACTIVE and the path supervision detects that the peer
      address is reachable again.

   SCTP_INACTIVE:  This state is entered whenever a path failure is
      detected.

spinfo_cwnd:  This contains the peer address's current congestion
   window.

spinfo_srtt:  This contains the peer address's current smoothed
   round-trip time calculation in milliseconds.

spinfo_rto:  This contains the peer address's current retransmission
   timeout value in milliseconds.

spinfo_mtu:  This is the current Path MTU of the peer address.  It is
   the number of bytes available in an SCTP packet for chunks.
]]></artwork>
	</figure>
	</section>

	<section title="Get the List of Chunks the Peer Requires to Be Authenticated (SCTP_PEER_AUTH_CHUNKS)" anchor="section-8.2.3"><t>
   This option gets a list of chunk types (see <xref target="RFC4960"/>) for a
   specified association that the peer requires to be received
   authenticated only.</t>

	<t>
   The following structure is used to access these parameters:</t>

	<figure><artwork><![CDATA[
struct sctp_authchunks {
  sctp_assoc_t gauth_assoc_id;
  uint32_t gauth_number_of_chunks
  uint8_t  gauth_chunks[];
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="gauth_assoc_id:">
	This parameter indicates for which association the
	<vspace blankLines="0"/>
	user is requesting the list of peer-authenticated chunks.  For
      one-to-one style sockets, this parameter is ignored.  Note that
      the predefined constants are not allowed with this option.
	</t>

	<t hangText="gauth_number_of_chunks:">
	This parameter gives the number of elements
	<vspace blankLines="0"/>
	in the array gauth_chunks.
	</t>

	<t hangText="gauth_chunks:">
	This parameter contains an array of chunk types that
	<vspace blankLines="0"/>
	the peer is requesting to be authenticated.  If the passed-in
      buffer size is not large enough to hold the list of chunk types,
      ENOBUFS is returned.
	</t>

	</list>
	</t>

	</section>

	<section title="Get the List of Chunks the Local Endpoint Requires to Be Authenticated (SCTP_LOCAL_AUTH_CHUNKS)" anchor="section-8.2.4"><t>
   This option gets a list of chunk types (see <xref target="RFC4960"/>) for a
   specified association that the local endpoint requires to be received
   authenticated only.</t>

	<t>
   The following structure is used to access these parameters:</t>

	<figure><artwork><![CDATA[
struct sctp_authchunks {
  sctp_assoc_t gauth_assoc_id;
  uint32_t gauth_number_of_chunks;
  uint8_t  gauth_chunks[];
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="gauth_assoc_id:">
	This parameter is ignored for one-to-one style
	<vspace blankLines="0"/>
	sockets.  For one-to-many style sockets, the application may fill
      in an association identifier or SCTP_FUTURE_ASSOC.  It is an error
      to use SCTP_{CURRENT|ALL}_ASSOC in gauth_assoc_id.
	</t>

	<t hangText="gauth_number_of_chunks:">
	This parameter gives the number of elements
	<vspace blankLines="0"/>
	in the array gauth_chunks.
	</t>

	<t hangText="gauth_chunks:">
	This parameter contains an array of chunk types that
	<vspace blankLines="0"/>
	the local endpoint is requesting to be authenticated.  If the
      passed-in buffer is not large enough to hold the list of chunk
      types, ENOBUFS is returned.
	</t>

	</list>
	</t>

	</section>

	<section title="Get the Current Number of Associations (SCTP_GET_ASSOC_NUMBER)" anchor="section-8.2.5"><t>
   This option gets the current number of associations that are attached
   to a one-to-many style socket.  The option value is an uint32_t.
   Note that this number is only a snapshot.  This means that the number
   of associations may have changed when the caller gets back the option
   result.</t>

	<t>
   For a one-to-one style socket, this socket option results in an
   error.</t>

	</section>

	<section title="Get the Current Identifiers of Associations (SCTP_GET_ASSOC_ID_LIST)" anchor="section-8.2.6"><t>
   This option gets the current list of SCTP association identifiers of
   the SCTP associations handled by a one-to-many style socket.</t>

	<t>
   The option value has the structure</t>

	<figure><artwork><![CDATA[
struct sctp_assoc_ids {
  uint32_t gaids_number_of_ids;
  sctp_assoc_t gaids_assoc_id[];
};
]]></artwork>
	</figure>
	<t>
   The caller must provide a large enough buffer to hold all association
   identifiers.  If the buffer is too small, an error must be returned.
   The user can use the SCTP_GET_ASSOC_NUMBER socket option to get an
   idea of how large the buffer has to be.  gaids_number_of_ids gives
   the number of elements in the array gaids_assoc_id.  Note also that
   some or all of sctp_assoc_t returned in the array may become invalid
   by the time the caller gets back the result.</t>

	<t>
   For a one-to-one style socket, this socket option results in an
   error.</t>

	</section>

	</section>

	<section title="Write-Only Options" anchor="section-8.3"><t>
   The options defined in this subsection are write-only.  Using this
   option in a getsockopt() or sctp_opt_info() call will result in an
   error indicating EOPNOTSUPP.</t>

	<section title="Set Peer Primary Address (SCTP_SET_PEER_PRIMARY_ADDR)" anchor="section-8.3.1"><t>
   This call requests that the peer mark the enclosed address as the
   association primary (see <xref target="RFC5061"/>).  The enclosed address must be
   one of the association's locally bound addresses.</t>

	<t>
   The following structure is used to make a set peer primary request:</t>

	<figure><artwork><![CDATA[
struct sctp_setpeerprim {
  sctp_assoc_t sspp_assoc_id;
  struct sockaddr_storage sspp_addr;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="sspp_assoc_id:">
	This parameter is ignored for one-to-one style
	<vspace blankLines="0"/>
	sockets.  For one-to-many style sockets, it identifies the
      association for this request.  Note that the predefined constants
      are not allowed for this option.
	</t>

	<t hangText="sspp_addr:">
	The address to set as primary.
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	</section>

	<section title="Add a Chunk That Must Be Authenticated (SCTP_AUTH_CHUNK)" anchor="section-8.3.2"><t>
   This set option adds a chunk type that the user is requesting to be
   received only in an authenticated way.  Changes to the list of chunks
   will only affect future associations on the socket.</t>

	<t>
   The following structure is used to add a chunk:</t>

	<figure><artwork><![CDATA[
struct sctp_authchunk {
  uint8_t sauth_chunk;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="sauth_chunk:">
	This parameter contains a chunk type that the user is
	<vspace blankLines="0"/>
	requesting to be authenticated.
	</t>

	</list>
	</t>

	<t>
   The chunk types for INIT, INIT-ACK, SHUTDOWN-COMPLETE, and AUTH
   chunks must not be used.  If they are used, an error must be
   returned.  The usage of this option enables SCTP AUTH in cases where
   it is not required by other means (for example, the use of dynamic
   address reconfiguration).</t>

	</section>

	<section title="Set a Shared Key (SCTP_AUTH_KEY)" anchor="section-8.3.3"><t>
   This option will set a shared secret key that is used to build an
   association shared key.</t>

	<t>
   The following structure is used to access and modify these
   parameters:</t>

	<figure><artwork><![CDATA[
struct sctp_authkey {
  sctp_assoc_t sca_assoc_id;
  uint16_t sca_keynumber;
  uint16_t sca_keylength;
  uint8_t  sca_key[];
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="sca_assoc_id:">
	This parameter indicates on what association the
	<vspace blankLines="0"/>
	shared key is being set.  The special SCTP_{FUTURE|CURRENT|
      ALL}_ASSOC can be used.  For one-to-one style sockets, this
      parameter is ignored.  Note, however, that on one-to-one style
      sockets, this option will set a key on the association if the
      socket is connected; otherwise, this option will set a key on the
      endpoint.
	</t>

	<t hangText="sca_keynumber:">
	This parameter is the shared key identifier by which
	<vspace blankLines="0"/>
	the application will refer to this shared key.  If a key of the
      specified index already exists, then this new key will replace the
      old existing key.  Note that shared key identifier '0' defaults to
      a null key.
	</t>

	<t hangText="sca_keylength:">
	This parameter is the length of the array sca_key.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sca_key:">
	This parameter contains an array of bytes that is to be
	<vspace blankLines="0"/>
	used by the endpoint (or association) as the shared secret key.
      Note that if the length of this field is zero, a null key is set.
	</t>

	</list>
	</t>

	</section>

	<section title="Deactivate a Shared Key (SCTP_AUTH_DEACTIVATE_KEY)" anchor="section-8.3.4"><t>
   This set option indicates that the application will no longer send
   user messages using the indicated key identifier.</t>

	<figure><artwork><![CDATA[
struct sctp_authkeyid {
  sctp_assoc_t scact_assoc_id;
  uint16_t scact_keynumber;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="scact_assoc_id:">
	This parameter indicates from which association the
	<vspace blankLines="0"/>
	shared key identifier is being deleted.  The special SCTP_{FUTURE|
      CURRENT|ALL}_ASSOC can be used.  For one-to-one style sockets,
      this parameter is ignored.  Note, however, that this option will
      deactivate the key from the association if the socket is
      connected; otherwise, this option will deactivate the key from the
      endpoint.
	</t>

	<t hangText="scact_keynumber:">
	This parameter is the shared key identifier that
	<vspace blankLines="0"/>
	the application is requesting to be deactivated.  The key
      identifier must correspond to an existing shared key.  Note that
      if this parameter is zero, use of the null key identifier '0' is
      deactivated on the endpoint and/or association.
	</t>

	</list>
	</t>

	<t>
   The currently active key cannot be deactivated.</t>

	</section>

	<section title="Delete a Shared Key (SCTP_AUTH_DELETE_KEY)" anchor="section-8.3.5"><t>
   This set option will delete an SCTP association's shared secret key
   that has been deactivated.</t>

	<figure><artwork><![CDATA[
struct sctp_authkeyid {
  sctp_assoc_t scact_assoc_id;
  uint16_t scact_keynumber;
};
]]></artwork>
	</figure>
	<t><list style="hanging" hangIndent="3"><t hangText="scact_assoc_id:">
	This parameter indicates from which association the
	<vspace blankLines="0"/>
	shared key identifier is being deleted.  The special SCTP_{FUTURE|
      CURRENT|ALL}_ASSOC can be used.  For one-to-one style sockets,
      this parameter is ignored.  Note, however, that this option will
      delete the key from the association if the socket is connected;
      otherwise, this option will delete the key from the endpoint.
	</t>

	<t hangText="scact_keynumber:">
	This parameter is the shared key identifier that
	<vspace blankLines="0"/>
	the application is requesting to be deleted.  The key identifier
      must correspond to an existing shared key and must not be in use
      for any packet being sent by the SCTP implementation.  This means,
      in particular, that it must be deactivated first.  Note that if
      this parameter is zero, use of the null key identifier '0' is
      deleted from the endpoint and/or association.
	</t>

	</list>
	</t>

	<t>
   Only deactivated keys that are no longer used by an association can
   be deleted.</t>

	</section>

	</section>

	</section>

	<section title="New Functions" anchor="section-9"><t>
   Depending on the system, the following interface can be implemented
   as a system call or library function.</t>

	<section title="sctp_bindx()" anchor="section-9.1"><t>
   This function allows the user to bind a specific subset of addresses
   or, if the SCTP extension described in <xref target="RFC5061"/> is supported, add or
   delete specific addresses.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="15"><t hangText="int sctp_bindx(int sd,">
	<vspace blankLines="0"/>
	struct sockaddr *addrs,
                  int addrcnt,
                  int flags);
	</t>

	</list>
	</t>

	<t>
   If sd is an IPv4 socket, the addresses passed must be IPv4 addresses.
   If the sd is an IPv6 socket, the addresses passed can either be IPv4
   or IPv6 addresses.</t>

	<t>
   A single address may be specified as INADDR_ANY for an IPv4 address,
   or as IN6ADDR_ANY_INIT or in6addr_any for an IPv6 address; see
   <xref target="section-3.1.2"/> for this usage.</t>

	<t>
   addrs is a pointer to an array of one or more socket addresses.  Each
   address is contained in its appropriate structure.  For an IPv6
   socket, an array of sockaddr_in6 is used.  For an IPv4 socket, an
   array of sockaddr_in is used.  The caller specifies the number of
   addresses in the array with addrcnt.  Note that the wildcard
   addresses cannot be used in combination with non-wildcard addresses
   on a socket with this function; doing so will result in an error.</t>

	<t>
   On success, sctp_bindx() returns 0.  On failure, sctp_bindx() returns
   -1 and sets errno to the appropriate error code.</t>

	<t>
   For SCTP, the port given in each socket address must be the same, or
   sctp_bindx() will fail, setting errno to EINVAL.</t>

	<t>
   The flags parameter is formed from the bitwise OR of zero or more of
   the following currently defined flags:</t>

	<t><list style="symbols"><t>SCTP_BINDX_ADD_ADDR</t>

	<t>SCTP_BINDX_REM_ADDR</t>

	</list>
	</t>

	<t>
   SCTP_BINDX_ADD_ADDR directs SCTP to add the given addresses to the
   socket (i.e., endpoint), and SCTP_BINDX_REM_ADDR directs SCTP to
   remove the given addresses from the socket.  The two flags are
   mutually exclusive; if both are given, sctp_bindx() will fail with
   EINVAL.  A caller may not remove all addresses from a socket;
   sctp_bindx() will reject such an attempt with EINVAL.</t>

	<t>
   An application can use sctp_bindx(SCTP_BINDX_ADD_ADDR) to associate
   additional addresses with an endpoint after calling bind().  Or, an
   application can use sctp_bindx(SCTP_BINDX_REM_ADDR) to remove some
   addresses with which a listening socket is associated, so that no new
   association accepted will be associated with these addresses.  If the
   endpoint supports dynamic address reconfiguration, an
   SCTP_BINDX_REM_ADDR or SCTP_BINDX_ADD_ADDR may cause an endpoint to
   send the appropriate message to its peers to change the peers'
   address lists.</t>

	<t>
   Adding and removing addresses from established associations is an
   optional functionality.  Implementations that do not support this
   functionality should return -1 and set errno to EOPNOTSUPP.</t>

	<t>
   sctp_bindx() can be called on an already bound socket or on an
   unbound socket.  If the socket is unbound and the first port number
   in the addrs parameter is zero, the kernel will choose a port number.
   All port numbers after the first one being 0 must also be zero.  If
   the first port number is not zero, the following port numbers must be
   zero or have the same value as the first one.  For an already bound
   socket, all port numbers provided must be the bound one or 0.</t>

	<t>
   sctp_bindx() is an atomic operation.  Therefore, the binding will
   either succeed on all addresses or fail on all addresses.  If
   multiple addresses are provided and the sctp_bindx() call fails,
   there is no indication of which address is responsible for the
   failure.  The only way to identify the specific error indication is
   to call sctp_bindx() sequentially with only one address per call.</t>

	</section>

	<section title="sctp_peeloff()" anchor="section-9.2"><t>
   After an association is established on a one-to-many style socket,
   the application may wish to branch off the association into a
   separate socket/file descriptor.</t>

	<t>
   This is particularly desirable when, for instance, the application
   wishes to have a number of sporadic message senders/receivers remain
   under the original one-to-many style socket but branch off these
   associations carrying high-volume data traffic into their own
   separate socket descriptors.</t>

	<t>
   The application uses the sctp_peeloff() call to branch off an
   association into a separate socket.  (Note that the semantics are
   somewhat changed from the traditional one-to-one style accept()
   call.)  Note also that the new socket is a one-to-one style socket.
   Thus, it will be confined to operations allowed for a one-to-one
   style socket.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="17"><t hangText="int sctp_peeloff(int sd,">
	<vspace blankLines="0"/>
	sctp_assoc_t assoc_id);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="3"><t hangText="sd:">
	The original one-to-many style socket descriptor returned from
	<vspace blankLines="0"/>
	the socket() system call (see <xref target="section-3.1.1"/>).
	</t>

	<t hangText="assoc_id:">
	The specified identifier of the association that is to be
	<vspace blankLines="0"/>
	branched off to a separate file descriptor.  (Note that in a
      traditional one-to-one style accept() call, this would be an out
      parameter, but for the one-to-many style call, this is an in
      parameter.)
	</t>

	</list>
	</t>

	<t>
   The function returns a non-negative file descriptor representing the
   branched-off association, or -1 if an error occurred.  The variable
   errno is then set appropriately.</t>

	</section>

	<section title="sctp_getpaddrs()" anchor="section-9.3"><t>
   sctp_getpaddrs() returns all peer addresses in an association.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="19"><t hangText="int sctp_getpaddrs(int sd,">
	<vspace blankLines="0"/>
	sctp_assoc_t id,
                      struct sockaddr **addrs);
	</t>

	</list>
	</t>

	<t>
   On return, addrs will point to a dynamically allocated array of
   sockaddr structures of the appropriate type for the socket type.  The
   caller should use sctp_freepaddrs() to free the memory.  Note that
   the in/out parameter addrs must not be NULL.</t>

	<t>
   If sd is an IPv4 socket, the addresses returned will be all IPv4
   addresses.  If sd is an IPv6 socket, the addresses returned can be a
   mix of IPv4 or IPv6 addresses, with IPv4 addresses returned according
   to the SCTP_I_WANT_MAPPED_V4_ADDR option setting.</t>

	<t>
   For one-to-many style sockets, id specifies the association to query.
   For one-to-one style sockets, id is ignored.</t>

	<t>
   On success, sctp_getpaddrs() returns the number of peer addresses in
   the association.  If there is no association on this socket,
   sctp_getpaddrs() returns 0, and the value of *addrs is undefined.  If
   an error occurs, sctp_getpaddrs() returns -1, and the value of *addrs
   is undefined.</t>

	</section>

	<section title="sctp_freepaddrs()" anchor="section-9.4"><t>
   sctp_freepaddrs() frees all resources allocated by sctp_getpaddrs().</t>

	<t>
   The function prototype is</t>

	<t>
   void sctp_freepaddrs(struct sockaddr *addrs);</t>

	<t>
   and addrs is the array of peer addresses returned by
   sctp_getpaddrs().</t>

	</section>

	<section title="sctp_getladdrs()" anchor="section-9.5"><t>
   sctp_getladdrs() returns all locally bound addresses on a socket.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="19"><t hangText="int sctp_getladdrs(int sd,">
	<vspace blankLines="0"/>
	sctp_assoc_t id,
                      struct sockaddr **addrs);
	</t>

	</list>
	</t>

	<t>
   On return, addrs will point to a dynamically allocated array of
   sockaddr structures of the appropriate type for the socket type.  The
   caller should use sctp_freeladdrs() to free the memory.  Note that
   the in/out parameter addrs must not be NULL.</t>

	<t>
   If sd is an IPv4 socket, the addresses returned will be all IPv4
   addresses.  If sd is an IPv6 socket, the addresses returned can be a
   mix of IPv4 or IPv6 addresses, with IPv4 addresses returned according
   to the SCTP_I_WANT_MAPPED_V4_ADDR option setting.</t>

	<t>
   For one-to-many style sockets, id specifies the association to query.
   For one-to-one style sockets, id is ignored.</t>

	<t>
   If the id field is set to the value '0', then the locally bound
   addresses are returned without regard to any particular association.</t>

	<t>
   On success, sctp_getladdrs() returns the number of local addresses
   bound to the socket.  If the socket is unbound, sctp_getladdrs()
   returns 0, and the value of *addrs is undefined.  If an error occurs,
   sctp_getladdrs() returns -1, and the value of *addrs is undefined.</t>

	</section>

	<section title="sctp_freeladdrs()" anchor="section-9.6"><t>
   sctp_freeladdrs() frees all resources allocated by sctp_getladdrs().</t>

	<t>
   The function prototype is</t>

	<t>
   void sctp_freeladdrs(struct sockaddr *addrs);</t>

	<t>
   and addrs is the array of local addresses returned by
   sctp_getladdrs().</t>

	</section>

	<section title="sctp_sendmsg() - DEPRECATED" anchor="section-9.7"><t>
   This function is deprecated; sctp_sendv() (see <xref target="section-9.12"/>) should
   be used instead.</t>

	<t>
   An implementation may provide a library function (or possibly system
   call) to assist the user with the advanced features of SCTP.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="21"><t hangText="ssize_t sctp_sendmsg(int sd,">
	<vspace blankLines="0"/>
	const void *msg,
                        size_t len,
                        const struct sockaddr *to,
                        socklen_t tolen,
                        uint32_t ppid,
                        uint32_t flags,
                        uint16_t stream_no,
                        uint32_t timetolive,
                        uint32_t context);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor.
	<vspace blankLines="0"/>
	</t>

	<t hangText="msg:">
	The message to be sent.
	<vspace blankLines="0"/>
	</t>

	<t hangText="len:">
	The length of the message.
	<vspace blankLines="0"/>
	</t>

	<t hangText="to:">
	The destination address of the message.
	<vspace blankLines="0"/>
	</t>

	<t hangText="tolen:">
	The length of the destination address.
	<vspace blankLines="0"/>
	</t>

	<t hangText="ppid:">
	The same as sinfo_ppid (see <xref target="section-5.3.2"/>).
	<vspace blankLines="0"/>
	</t>

	<t hangText="flags:">
	The same as sinfo_flags (see <xref target="section-5.3.2"/>).
	<vspace blankLines="0"/>
	</t>

	<t hangText="stream_no:">
	The same as sinfo_stream (see <xref target="section-5.3.2"/>).
	<vspace blankLines="0"/>
	</t>

	<t hangText="timetolive:">
	The same as sinfo_timetolive (see <xref target="section-5.3.2"/>).
	<vspace blankLines="0"/>
	</t>

	<t hangText="context:">
	The same as sinfo_context (see <xref target="section-5.3.2"/>).
	<vspace blankLines="0"/>
	</t>

	</list>
	</t>

	<t>
   The call returns the number of characters sent, or -1 if an error
   occurred.  The variable errno is then set appropriately.</t>

	<t>
   Sending a message using sctp_sendmsg() is atomic (unless explicit EOR
   marking is enabled on the socket specified by sd).</t>

	<t>
   Using sctp_sendmsg() on a non-connected one-to-one style socket for
   implicit connection setup may or may not work, depending on the SCTP
   implementation.</t>

	</section>

	<section title="sctp_recvmsg() - DEPRECATED" anchor="section-9.8"><t>
   This function is deprecated; sctp_recvv() (see <xref target="section-9.13"/>) should
   be used instead.</t>

	<t>
   An implementation may provide a library function (or possibly system
   call) to assist the user with the advanced features of SCTP.  Note
   that in order for the sctp_sndrcvinfo structure to be filled in by
   sctp_recvmsg(), the caller must enable the sctp_data_io_event with
   the SCTP_EVENTS option.  Note that the setting of the
   SCTP_USE_EXT_RCVINFO will affect this function as well, causing the
   sctp_sndrcvinfo information to be extended.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="21"><t hangText="ssize_t sctp_recvmsg(int sd,">
	<vspace blankLines="0"/>
	void *msg,
                        size_t len,
                        struct sockaddr *from,
                        socklen_t *fromlen
                        struct sctp_sndrcvinfo *sinfo
                        int *msg_flags);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor.
	<vspace blankLines="0"/>
	</t>

	<t hangText="msg:">
	The message buffer to be filled.
	<vspace blankLines="0"/>
	</t>

	<t hangText="len:">
	The length of the message buffer.
	<vspace blankLines="0"/>
	</t>

	<t hangText="from:">
	A pointer to an address to be filled with the address of the
	<vspace blankLines="0"/>
	sender of this message.
	</t>

	<t hangText="fromlen:">
	An in/out parameter describing the from length.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sinfo:">
	A pointer to an sctp_sndrcvinfo structure to be filled upon
	<vspace blankLines="0"/>
	receipt of the message.
	</t>

	<t hangText="msg_flags:">
	A pointer to an integer to be filled with any message
	<vspace blankLines="0"/>
	flags (e.g., MSG_NOTIFICATION).  Note that this field is an in-out
      field.  Options for the receive may also be passed into the value
      (e.g., MSG_PEEK).  On return from the call, the msg_flags value
      will be different than what was sent in to the call.  If
      implemented via a recvmsg() call, the msg_flags parameter should
      only contain the value of the flags from the recvmsg() call.
	</t>

	</list>
	</t>

	<t>
   The call returns the number of bytes received, or -1 if an error
   occurred.  The variable errno is then set appropriately.</t>

	</section>

	<section title="sctp_connectx()" anchor="section-9.9"><t>
   An implementation may provide a library function (or possibly system
   call) to assist the user with associating to an endpoint that is
   multi-homed.  Much like sctp_bindx(), this call allows a caller to
   specify multiple addresses at which a peer can be reached.  The way
   the SCTP stack uses the list of addresses to set up the association
   is implementation dependent.  This function only specifies that the
   stack will try to make use of all of the addresses in the list when
   needed.</t>

	<t>
   Note that the list of addresses passed in is only used for setting up
   the association.  It does not necessarily equal the set of addresses
   the peer uses for the resulting association.  If the caller wants to
   find out the set of peer addresses, it must use sctp_getpaddrs() to
   retrieve them after the association has been set up.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="18"><t hangText="int sctp_connectx(int sd,">
	<vspace blankLines="0"/>
	struct sockaddr *addrs,
                     int addrcnt,
                     sctp_assoc_t *id);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor.
	<vspace blankLines="0"/>
	</t>

	<t hangText="addrs:">
	An array of addresses.
	<vspace blankLines="0"/>
	</t>

	<t hangText="addrcnt:">
	The number of addresses in the array.
	<vspace blankLines="0"/>
	</t>

	<t hangText="id:">
	An output parameter that, if passed in as non-NULL, will return
	<vspace blankLines="0"/>
	the association identifier for the newly created association (if
      successful).
	</t>

	</list>
	</t>

	<t>
   The call returns 0 on success or -1 if an error occurred.  The
   variable errno is then set appropriately.</t>

	</section>

	<section title="sctp_send() - DEPRECATED" anchor="section-9.10"><t>
   This function is deprecated; sctp_sendv() should be used instead.</t>

	<t>
   An implementation may provide another alternative function or system
   call to assist an application with the sending of data without the
   use of the cmsghdr structures.</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="18"><t hangText="ssize_t sctp_send(int sd,">
	<vspace blankLines="0"/>
	const void *msg,
                     size_t len,
                     const struct sctp_sndrcvinfo *sinfo,
                     int flags);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor.
	<vspace blankLines="0"/>
	</t>

	<t hangText="msg:">
	The message to be sent.
	<vspace blankLines="0"/>
	</t>

	<t hangText="len:">
	The length of the message.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sinfo:">
	A pointer to an sctp_sndrcvinfo structure used as described
	<vspace blankLines="0"/>
	in <xref target="section-5.3.2"/> for a sendmsg() call.
	</t>

	<t hangText="flags:">
	The same flags as used by the sendmsg() call flags (e.g.,
	<vspace blankLines="0"/>
	MSG_DONTROUTE).
	</t>

	</list>
	</t>

	<t>
   The call returns the number of bytes sent, or -1 if an error
   occurred.  The variable errno is then set appropriately.</t>

	<t>
   This function call may also be used to terminate an association using
   an association identifier by setting the sinfo.sinfo_flags to
   SCTP_EOF and the sinfo.sinfo_assoc_id to the association that needs
   to be terminated.  In such a case, len can be zero.</t>

	<t>
   Using sctp_send() on a non-connected one-to-one style socket for
   implicit connection setup may or may not work, depending on the SCTP
   implementation.</t>

	<t>
   Sending a message using sctp_send() is atomic unless explicit EOR
   marking is enabled on the socket specified by sd.</t>

	</section>

	<section title="sctp_sendx() - DEPRECATED" anchor="section-9.11"><t>
   This function is deprecated; sctp_sendv() should be used instead.</t>

	<t>
   An implementation may provide another alternative function or system
   call to assist an application with the sending of data without the
   use of the cmsghdr structure, and to provide a list of addresses.
   The list of addresses is provided for implicit association setup.  In
   such a case, the list of addresses serves the same purpose as the
   addresses given in sctp_connectx() (see <xref target="section-9.9"/>).</t>

	<t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="19"><t hangText="ssize_t sctp_sendx(int sd,">
	<vspace blankLines="0"/>
	const void *msg,
                      size_t len,
                      struct sockaddr *addrs,
                      int addrcnt,
                      struct sctp_sndrcvinfo *sinfo,
                      int flags);
	</t>

	</list>
	</t>

	<t>
   and the arguments are</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor.
	<vspace blankLines="0"/>
	</t>

	<t hangText="msg:">
	The message to be sent.
	<vspace blankLines="0"/>
	</t>

	<t hangText="len:">
	The length of the message.
	<vspace blankLines="0"/>
	</t>

	<t hangText="addrs:">
	An array of addresses.
	<vspace blankLines="0"/>
	</t>

	<t hangText="addrcnt:">
	The number of addresses in the array.
	<vspace blankLines="0"/>
	</t>

	<t hangText="sinfo:">
	A pointer to an sctp_sndrcvinfo structure used as described
	<vspace blankLines="0"/>
	in <xref target="section-5.3.2"/> for a sendmsg() call.
	</t>

	<t hangText="flags:">
	The same flags as used by the sendmsg() call flags (e.g.,
	<vspace blankLines="0"/>
	MSG_DONTROUTE).
	</t>

	</list>
	</t>

	<t>
   The call returns the number of bytes sent, or -1 if an error
   occurred.  The variable errno is then set appropriately.</t>

	<t>
   Note that in the case of implicit connection setup, on return from
   this call, the sinfo_assoc_id field of the sinfo structure will
   contain the new association identifier.</t>

	<t>
   This function call may also be used to terminate an association using
   an association identifier by setting the sinfo.sinfo_flags to
   SCTP_EOF and the sinfo.sinfo_assoc_id to the association that needs
   to be terminated.  In such a case, len would be zero.</t>

	<t>
   Sending a message using sctp_sendx() is atomic unless explicit EOR
   marking is enabled on the socket specified by sd.</t>

	<t>
   Using sctp_sendx() on a non-connected one-to-one style socket for
   implicit connection setup may or may not work, depending on the SCTP
   implementation.</t>

	</section>

	<section title="sctp_sendv()" anchor="section-9.12"><t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="19"><t hangText="ssize_t sctp_sendv(int sd,">
	<vspace blankLines="0"/>
	const struct iovec *iov,
                      int iovcnt,
                      struct sockaddr *addrs,
                      int addrcnt,
                      void *info,
                      socklen_t infolen,
                      unsigned int infotype,
                      int flags);
	</t>

	</list>
	</t>

	<t>
   The function sctp_sendv() provides an extensible way for an
   application to communicate different send attributes to the SCTP
   stack when sending a message.  An implementation may provide
   sctp_sendv() as a library function or a system call.</t>

	<t>
   This document defines three types of attributes that can be used to
   describe a message to be sent.  They are struct sctp_sndinfo
   (<xref target="section-5.3.4"/>), struct sctp_prinfo (<xref target="section-5.3.7"/>), and struct
   sctp_authinfo (<xref target="section-5.3.8"/>).  The following structure,
   sctp_sendv_spa, is defined to be used when more than one of the above
   attributes are needed to describe a message to be sent.</t>

	<figure><artwork><![CDATA[
struct sctp_sendv_spa {
  uint32_t sendv_flags;
  struct sctp_sndinfo sendv_sndinfo;
  struct sctp_prinfo sendv_prinfo;
  struct sctp_authinfo sendv_authinfo;
};
]]></artwork>
	</figure>
	<t>
   The sendv_flags field holds a bitwise OR of SCTP_SEND_SNDINFO_VALID,
   SCTP_SEND_PRINFO_VALID, and SCTP_SEND_AUTHINFO_VALID indicating if
   the sendv_sndinfo/sendv_prinfo/sendv_authinfo fields contain valid
   information.</t>

	<t>
   In future, when new send attributes are needed, new structures can be
   defined.  But those new structures do not need to be based on any of
   the above defined structures.</t>

	<t>
   The function takes the following arguments:</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor.
	<vspace blankLines="0"/>
	</t>

	<t hangText="iov:">
	The gather buffer.  The data in the buffer is treated as a
	<vspace blankLines="0"/>
	single user message.
	</t>

	<t hangText="iovcnt:">
	The number of elements in iov.
	<vspace blankLines="0"/>
	</t>

	<t hangText="addrs:">
	An array of addresses to be used to set up an association or
	<vspace blankLines="0"/>
	a single address to be used to send the message.  NULL is passed
      in if the caller neither wants to set up an association nor wants
      to send the message to a specific address.
	</t>

	<t hangText="addrcnt:">
	The number of addresses in the addrs array.
	<vspace blankLines="0"/>
	</t>

	<t hangText="info:">
	A pointer to the buffer containing the attribute associated
	<vspace blankLines="0"/>
	with the message to be sent.  The type is indicated by the
      info_type parameter.
	</t>

	<t hangText="infolen:">
	The length of info, in bytes.
	<vspace blankLines="0"/>
	</t>

	<t hangText="infotype:">
	Identifies the type of the information provided in info.
	<vspace blankLines="0"/>
	The current defined values are as follows:
	<vspace blankLines="1"/>
	SCTP_SENDV_NOINFO:  No information is provided.  The parameter
         info is a NULL pointer, and infolen is 0.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_SENDV_SNDINFO:">
	The parameter info is pointing to a struct
	<vspace blankLines="0"/>
	sctp_sndinfo.
	</t>

	<t hangText="SCTP_SENDV_PRINFO:">
	The parameter info is pointing to a struct
	<vspace blankLines="0"/>
	sctp_prinfo.
	</t>

	<t hangText="SCTP_SENDV_AUTHINFO:">
	The parameter info is pointing to a struct
	<vspace blankLines="0"/>
	sctp_authinfo.
	</t>

	<t hangText="SCTP_SENDV_SPA:">
	The parameter info is pointing to a struct
	<vspace blankLines="0"/>
	sctp_sendv_spa.
	</t>

	</list>
	</t>

	<t hangText="flags:">
	The same flags as used by the sendmsg() call flags (e.g.,
	<vspace blankLines="0"/>
	MSG_DONTROUTE).
	</t>

	</list>
	</t>

	<t>
   The call returns the number of bytes sent, or -1 if an error
   occurred.  The variable errno is then set appropriately.</t>

	<t>
   A note on the one-to-many style socket: The struct sctp_sndinfo
   attribute must always be used in order to specify the association on
   which the message is to be sent.  The only case where it is not
   needed is when this call is used to set up a new association.</t>

	<t>
   The caller provides a list of addresses in the addrs parameter to set
   up an association.  This function will behave like calling
   sctp_connectx() (see <xref target="section-9.9"/>), first using the list of addresses
   and then calling sendmsg() with the given message and attributes.
   For a one-to-many style socket, if the struct sctp_sndinfo attribute
   is provided, the snd_assoc_id field must be 0.  When this function
   returns, the snd_assoc_id field will contain the association
   identifier of the newly established association.  Note that the
   struct sctp_sndinfo attribute is not required to set up an
   association for a one-to-many style socket.  If this attribute is not
   provided, the caller can enable the SCTP_ASSOC_CHANGE notification
   and use the SCTP_COMM_UP message to find out the association
   identifier.</t>

	<t>
   If the caller wants to send the message to a specific peer address
   (hence overriding the primary address), it can provide the specific
   address in the addrs parameter and provide a struct sctp_sndinfo
   attribute with the field snd_flags set to SCTP_ADDR_OVER.</t>

	<t>
   This function call may also be used to terminate an association.  The
   caller provides an sctp_sndinfo attribute with the snd_flags set to
   SCTP_EOF.  In this case, len would be zero.</t>

	<t>
   Sending a message using sctp_sendv() is atomic unless explicit EOR
   marking is enabled on the socket specified by sd.</t>

	</section>

	<section title="sctp_recvv()" anchor="section-9.13"><t>
   The function prototype is</t>

	<t><list style="hanging" hangIndent="19"><t hangText="ssize_t sctp_recvv(int sd,">
	<vspace blankLines="0"/>
	const struct iovec *iov,
                      int iovlen,
                      struct sockaddr *from,
                      socklen_t *fromlen,
                      void *info,
                      socklen_t *infolen,
                      unsigned int *infotype,
                      int *flags);
	</t>

	</list>
	</t>

	<t>
   The function sctp_recvv() provides an extensible way for the SCTP
   stack to pass up different SCTP attributes associated with a received
   message to an application.  An implementation may provide
   sctp_recvv() as a library function or as a system call.</t>

	<t>
   This document defines two types of attributes that can be returned by
   this call: the attribute of the received message and the attribute of
   the next message in the receive buffer.  The caller enables the
   SCTP_RECVRCVINFO and SCTP_RECVNXTINFO socket options, respectively,
   to receive these attributes.  Attributes of the received message are
   returned in struct sctp_rcvinfo (<xref target="section-5.3.5"/>), and attributes of
   the next message are returned in struct sctp_nxtinfo (<xref target="section-5.3.6"/>).
   If both options are enabled, both attributes are returned using the
   following structure.</t>

	<figure><artwork><![CDATA[
struct sctp_recvv_rn {
  struct sctp_rcvinfo recvv_rcvinfo;
  struct sctp_nxtinfo recvv_nxtinfo;
};
]]></artwork>
	</figure>
	<t>
   In future, new structures can be defined to hold new types of
   attributes.  The new structures do not need to be based on struct
   sctp_recvv_rn or struct sctp_rcvinfo.</t>

	<t>
   This function takes the following arguments:</t>

	<t><list style="hanging" hangIndent="-1"><t hangText="sd:">
	The socket descriptor.
	<vspace blankLines="0"/>
	</t>

	<t hangText="iov:">
	The scatter buffer.  Only one user message is returned in this
	<vspace blankLines="0"/>
	buffer.
	</t>

	<t hangText="iovlen:">
	The number of elements in iov.
	<vspace blankLines="0"/>
	</t>

	<t hangText="from:">
	A pointer to an address to be filled with the sender of the
	<vspace blankLines="0"/>
	received message's address.
	</t>

	<t hangText="fromlen:">
	An in/out parameter describing the from length.
	<vspace blankLines="0"/>
	</t>

	<t hangText="info:">
	A pointer to the buffer to hold the attributes of the received
	<vspace blankLines="0"/>
	message.  The structure type of info is determined by the
      info_type parameter.
	</t>

	<t hangText="infolen:">
	An in/out parameter describing the size of the info buffer.
	<vspace blankLines="0"/>
	</t>

	<t hangText="infotype:">
	On return, *info_type is set to the type of the info
	<vspace blankLines="0"/>
	buffer.  The current defined values are as follows:
	<vspace blankLines="1"/>
	SCTP_RECVV_NOINFO:  If both SCTP_RECVRCVINFO and SCTP_RECVNXTINFO
         options are not enabled, no attribute will be returned.  If
         only the SCTP_RECVNXTINFO option is enabled but there is no
         next message in the buffer, no attribute will be returned.  In
         these cases, *info_type will be set to SCTP_RECVV_NOINFO.
	<list style="hanging" hangIndent="3"><t hangText="SCTP_RECVV_RCVINFO:">
	The type of info is struct sctp_rcvinfo, and
	<vspace blankLines="0"/>
	the attribute relates to the received message.
	</t>

	<t hangText="SCTP_RECVV_NXTINFO:">
	The type of info is struct sctp_nxtinfo, and
	<vspace blankLines="0"/>
	the attribute relates to the next message in the receive
         buffer.  This is the case when only the SCTP_RECVNXTINFO option
         is enabled and there is a next message in the buffer.
	</t>

	<t hangText="SCTP_RECVV_RN:">
	The type of info is struct sctp_recvv_rn.  The
	<vspace blankLines="0"/>
	recvv_rcvinfo field is the attribute of the received message,
         and the recvv_nxtinfo field is the attribute of the next
         message in the buffer.  This is the case when both
         SCTP_RECVRCVINFO and SCTP_RECVNXTINFO options are enabled and
         there is a next message in the receive buffer.
	</t>

	</list>
	</t>

	<t hangText="flags:">
	A pointer to an integer to be filled with any message flags
	<vspace blankLines="0"/>
	(e.g., MSG_NOTIFICATION).  Note that this field is an in/out
      parameter.  Options for the receive may also be passed into the
      value (e.g., MSG_PEEK).  On return from the call, the flags value
      will be different than what was sent in to the call.  If
      implemented via a recvmsg() call, the flags should only contain
      the value of the flags from the recvmsg() call when calling
      sctp_recvv(), and on return it has the value from msg_flags.
	</t>

	</list>
	</t>

	<t>
   The call returns the number of bytes received, or -1 if an error
   occurred.  The variable errno is then set appropriately.</t>

	</section>

	</section>

	<section title="Security Considerations" anchor="section-10"><t>
   Many TCP and UDP implementations reserve port numbers below 1024 for
   privileged users.  If the target platform supports privileged users,
   the SCTP implementation should restrict the ability to call bind() or
   sctp_bindx() on these port numbers to privileged users.</t>

	<t>
   Similarly, unprivileged users should not be able to set protocol
   parameters that could result in the congestion control algorithm
   being more aggressive than permitted on the public Internet.  These
   parameters are as follows:</t>

	<t><list style="symbols"><t>struct sctp_rtoinfo</t>

	</list>
	</t>

	<t>
   If an unprivileged user inherits a one-to-many style socket with open
   associations on a privileged port, accepting new associations might
   be permitted, but opening new associations should not be permitted.
   This could be relevant for the r* family (rsh, rlogin, rwho, ...) of
   protocols.</t>

	<t>
   Applications using the one-to-many style sockets and using the
   interleave level (if 0) are subject to denial-of-service attacks, as
   described in <xref target="section-8.1.20"/>.</t>

	<t>
   Applications needing transport layer security can use Datagram
   Transport Layer Security/SCTP (DTLS/SCTP) as specified in <xref target="RFC6083"/>.
   This can be implemented using the sockets API described in this
   document.</t>

	</section>

	<section title="Acknowledgments" anchor="section-11"><t>
   Special acknowledgment is given to Ken Fujita, Jonathan Woods,
   Qiaobing Xie, and La Monte Yarroll, who helped extensively in the
   early formation of this document.</t>

	<t>
   The authors also wish to thank Kavitha Baratakke, Mike Bartlett,
   Martin Becke, Jon Berger, Mark Butler, Thomas Dreibholz, Andreas
   Fink, Scott Kimble, Jonathan Leighton, Renee Revis, Irene Ruengeler,
   Dan Wing, and many others on the TSVWG mailing list for contributing
   valuable comments.</t>

	<t>
   A special thanks to Phillip Conrad, for his suggested text, quick and
   constructive insights, and most of all his persistent fighting to
   keep the interface to SCTP usable for the application programmer.</t>

	</section>

	</middle>

	<back>
	<references title="Normative References">
	<reference anchor="IEEE-1003.1-2008"><front>
	<title>Information Technology - Portable Operating System Interface (POSIX)</title>
	<author>
	<organization>Institute of Electrical and Electronics Engineers</organization>
	</author>

	<date year="2008"/>
	</front>

	<seriesInfo name="IEEE" value="Standard 1003.1"/>
	</reference>
	&RFC3493;
	&RFC3542;
	&RFC3758;
	&RFC4895;
	&RFC4960;
	&RFC5061;
	</references>
	<references title="Informative References">
	&RFC0768;
	&RFC0793;
	&RFC1644;
	&RFC6083;
	&RFC6247;
	</references>
	<section title="Example Using One-to-One Style Sockets" anchor="section-a"><t>
   The following code is an implementation of a simple client that sends
   a number of messages marked for unordered delivery to an echo server
   making use of all outgoing streams.  The example shows how to use
   some features of one-to-one style IPv4 SCTP sockets, including</t>

	<figure><artwork><![CDATA[
o  Creating and connecting an SCTP socket.

o  Making a request to negotiate a number of outgoing streams.

o  Determining the negotiated number of outgoing streams.

o  Setting an adaptation layer indication.

o  Sending messages with a given payload protocol identifier on a
   particular stream using sctp_sendv().

<CODE BEGINS>
/*

   Copyright (c) 2011 IETF Trust and the persons identified
   as authors of the code.  All rights reserved.

   Redistribution and use in source and binary forms, with
   or without modification, is permitted pursuant to, and subject
   to the license terms contained in, the Simplified BSD License
   set forth in Section 4.c of the IETF Trust's Legal Provisions
   Relating to IETF Documents (http://trustee.ietf.org/license-info).

*/

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/sctp.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#define PORT 9
#define ADDR "127.0.0.1"
#define SIZE_OF_MESSAGE 1000
#define NUMBER_OF_MESSAGES 10
#define PPID 1234

int
main(void) {
  unsigned int i;
  int sd;
  struct sockaddr_in addr;
  char buffer[SIZE_OF_MESSAGE];
  struct iovec iov;
  struct sctp_status status;
  struct sctp_initmsg init;
  struct sctp_sndinfo info;
  struct sctp_setadaptation ind;
  socklen_t opt_len;

  /* Create a one-to-one style SCTP socket. */
  if ((sd = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP)) < 0) {
    perror("socket");
    exit(1);
  }

  /* Prepare for requesting 2048 outgoing streams. */
  memset(&init, 0, sizeof(init));
  init.sinit_num_ostreams = 2048;
  if (setsockopt(sd, IPPROTO_SCTP, SCTP_INITMSG,
                 &init, (socklen_t)sizeof(init)) < 0) {
    perror("setsockopt");
    exit(1);
  }

  ind.ssb_adaptation_ind  = 0x01020304;
  if (setsockopt(sd, IPPROTO_SCTP, SCTP_ADAPTATION_LAYER,
                 &ind, (socklen_t)sizeof(ind)) < 0) {
    perror("setsockopt");
    exit(1);
  }

  /* Connect to the discard server. */
  memset(&addr, 0, sizeof(addr));
#ifdef HAVE_SIN_LEN
  addr.sin_len         = sizeof(struct sockaddr_in);
#endif
  addr.sin_family      = AF_INET;
  addr.sin_port        = htons(PORT);
  addr.sin_addr.s_addr = inet_addr(ADDR);

  if (connect(sd,
              (const struct sockaddr *)&addr,
              sizeof(struct sockaddr_in)) < 0) {
    perror("connect");
    exit(1);
  }

  /* Get the actual number of outgoing streams. */
  memset(&status, 0, sizeof(status));
  opt_len = (socklen_t)sizeof(status);
  if (getsockopt(sd, IPPROTO_SCTP, SCTP_STATUS,
                 &status, &opt_len) < 0) {
    perror("getsockopt");
    exit(1);
  }

  memset(&info, 0, sizeof(info));
  info.snd_ppid = htonl(PPID);
  info.snd_flags = SCTP_UNORDERED;
  memset(buffer, 'A', SIZE_OF_MESSAGE);
  iov.iov_base = buffer;
  iov.iov_len = SIZE_OF_MESSAGE;
  for (i = 0; i <  NUMBER_OF_MESSAGES; i++) {
    info.snd_sid = i % status.sstat_outstrms;
    if (sctp_sendv(sd,
                   (const struct iovec *)&iov, 1,
                   NULL, 0,
                   &info, sizeof(info), SCTP_SENDV_SNDINFO,
                   0) < 0) {
      perror("sctp_sendv");
      exit(1);
    }
  }

  if (close(sd) < 0) {
    perror("close");
    exit(1);
  }
  return(0);
}
<CODE ENDS>
]]></artwork>
	</figure>
	</section>

	<section title="Example Using One-to-Many Style Sockets" anchor="section-b"><t>
   The following code is a simple implementation of a discard server
   over SCTP.  The example shows how to use some features of one-to-many
   style IPv6 SCTP sockets, including</t>

	<t><list style="symbols"><t>Opening and binding of a socket.</t>

	<t>Enabling notifications.</t>

	<t>Handling notifications.</t>

	<t>Configuring the auto-close timer.</t>

	<t>Using sctp_recvv() to receive messages.</t>

	</list>
	</t>

	<t>
   Please note that this server can be used in combination with the
   client described in Appendix A.</t>

	<figure><artwork><![CDATA[
<CODE BEGINS>
/*

   Copyright (c) 2011 IETF Trust and the persons identified
   as authors of the code.  All rights reserved.

   Redistribution and use in source and binary forms, with
   or without modification, is permitted pursuant to, and subject
   to the license terms contained in, the Simplified BSD License
   set forth in Section 4.c of the IETF Trust's Legal Provisions
   Relating to IETF Documents (http://trustee.ietf.org/license-info).

*/

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/sctp.h>
#include <arpa/inet.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define BUFFER_SIZE (1<<16)
#define PORT 9
#define ADDR "0.0.0.0"
#define TIMEOUT 5

static void
print_notification(void *buf)
{
  struct sctp_assoc_change *sac;
  struct sctp_paddr_change *spc;
  struct sctp_adaptation_event *sad;
  union sctp_notification *snp;
  char addrbuf[INET6_ADDRSTRLEN];
  const char *ap;
  struct sockaddr_in *sin;
  struct sockaddr_in6 *sin6;

  snp = buf;

  switch (snp->sn_header.sn_type) {
  case SCTP_ASSOC_CHANGE:
    sac = &snp->sn_assoc_change;
    printf("^^^ Association change: ");
    switch (sac->sac_state) {
    case SCTP_COMM_UP:
      printf("Communication up (streams (in/out)=(%u/%u)).\n",
             sac->sac_inbound_streams, sac->sac_outbound_streams);
      break;
    case SCTP_COMM_LOST:
      printf("Communication lost (error=%d).\n", sac->sac_error);
      break;
    case SCTP_RESTART:
      printf("Communication restarted (streams (in/out)=(%u/%u).\n",
             sac->sac_inbound_streams, sac->sac_outbound_streams);
      break;
    case SCTP_SHUTDOWN_COMP:
      printf("Communication completed.\n");
      break;
    case SCTP_CANT_STR_ASSOC:
      printf("Communication couldn't be started.\n");
      break;
    default:
      printf("Unknown state: %d.\n", sac->sac_state);
      break;
    }
    break;
  case SCTP_PEER_ADDR_CHANGE:
    spc = &snp->sn_paddr_change;
    if (spc->spc_aaddr.ss_family == AF_INET) {
      sin = (struct sockaddr_in *)&spc->spc_aaddr;
      ap = inet_ntop(AF_INET, &sin->sin_addr,
                     addrbuf, INET6_ADDRSTRLEN);
    } else {

      sin6 = (struct sockaddr_in6 *)&spc->spc_aaddr;
      ap = inet_ntop(AF_INET6, &sin6->sin6_addr,
                     addrbuf, INET6_ADDRSTRLEN);
    }
    printf("^^^ Peer Address change: %s ", ap);
    switch (spc->spc_state) {
    case SCTP_ADDR_AVAILABLE:
      printf("is available.\n");
      break;
    case SCTP_ADDR_UNREACHABLE:
      printf("is not available (error=%d).\n", spc->spc_error);
      break;
    case SCTP_ADDR_REMOVED:
      printf("was removed.\n");
      break;
    case SCTP_ADDR_ADDED:
      printf("was added.\n");
      break;
    case SCTP_ADDR_MADE_PRIM:
      printf("is primary.\n");
      break;
    default:
      printf("unknown state (%d).\n", spc->spc_state);
      break;
    }
    break;
  case SCTP_SHUTDOWN_EVENT:
    printf("^^^ Shutdown received.\n");
    break;
  case SCTP_ADAPTATION_INDICATION:
    sad = &snp->sn_adaptation_event;
    printf("^^^ Adaptation indication 0x%08x received.\n",
           sad->sai_adaptation_ind);
    break;
  default:
    printf("^^^ Unknown event of type: %u.\n",
           snp->sn_header.sn_type);
    break;
  };
}

int
main(void) {
  int sd, flags, timeout, on;
  ssize_t n;
  unsigned int i;
  union {
    struct sockaddr sa;
    struct sockaddr_in sin;
    struct sockaddr_in6 sin6;
  } addr;
  socklen_t fromlen, infolen;
  struct sctp_rcvinfo info;
  unsigned int infotype;
  struct iovec iov;
  char buffer[BUFFER_SIZE];
  struct sctp_event event;
  uint16_t event_types[] = {SCTP_ASSOC_CHANGE,
                            SCTP_PEER_ADDR_CHANGE,
                            SCTP_SHUTDOWN_EVENT,
                            SCTP_ADAPTATION_INDICATION};

  /* Create a one-to-many style SCTP socket. */
  if ((sd = socket(AF_INET6, SOCK_SEQPACKET, IPPROTO_SCTP)) < 0) {
    perror("socket");
    exit(1);
  }

  /* Enable the events of interest. */
  memset(&event, 0, sizeof(event));
  event.se_assoc_id = SCTP_FUTURE_ASSOC;
  event.se_on = 1;
  for (i = 0; i < sizeof(event_types)/sizeof(uint16_t); i++) {
    event.se_type = event_types[i];
    if (setsockopt(sd, IPPROTO_SCTP, SCTP_EVENT,
                   &event, sizeof(event)) < 0) {
      perror("setsockopt");
      exit(1);
    }
  }

  /* Configure auto-close timer. */
  timeout = TIMEOUT;
  if (setsockopt(sd, IPPROTO_SCTP, SCTP_AUTOCLOSE,
                 &timeout, sizeof(timeout)) < 0) {
    perror("setsockopt SCTP_AUTOCLOSE");
    exit(1);
  }

  /* Enable delivery of SCTP_RCVINFO. */
  on = 1;
  if (setsockopt(sd, IPPROTO_SCTP, SCTP_RECVRCVINFO,
                 &on, sizeof(on)) < 0) {
    perror("setsockopt SCTP_RECVRCVINFO");
    exit(1);
  }

  /* Bind the socket to all local addresses. */
  memset(&addr, 0, sizeof(addr));
#ifdef HAVE_SIN6_LEN
  addr.sin6.sin6_len         = sizeof(addr.sin6);
#endif
  addr.sin6.sin6_family      = AF_INET6;
  addr.sin6.sin6_port        = htons(PORT);
  addr.sin6.sin6_addr        = in6addr_any;
  if (bind(sd, &addr.sa, sizeof(addr.sin6)) < 0) {
    perror("bind");
    exit(1);
  }
  /* Enable accepting associations. */
  if (listen(sd, 1) < 0) {
    perror("listen");
    exit(1);
  }

  for (;;) {
    flags = 0;
    memset(&addr, 0, sizeof(addr));
    fromlen = (socklen_t)sizeof(addr);
    memset(&info, 0, sizeof(info));
    infolen = (socklen_t)sizeof(info);
    infotype = 0;
    iov.iov_base = buffer;
    iov.iov_len = BUFFER_SIZE;

    n = sctp_recvv(sd, &iov, 1,
                   &addr.sa, &fromlen,
                   &info, &infolen, &infotype,
                   &flags);

    if (flags & MSG_NOTIFICATION) {
      print_notification(iov.iov_base);
    } else {
      char addrbuf[INET6_ADDRSTRLEN];
      const char *ap;
      in_port_t port;

      if (addr.sa.sa_family == AF_INET) {
             ap = inet_ntop(AF_INET, &addr.sin.sin_addr,
                            addrbuf, INET6_ADDRSTRLEN);
             port = ntohs(addr.sin.sin_port);
      } else {
             ap = inet_ntop(AF_INET6, &addr.sin6.sin6_addr,
                            addrbuf, INET6_ADDRSTRLEN);
             port = ntohs(addr.sin6.sin6_port);
      }
      printf("Message received from %s:%u: len=%d",
             ap, port, (int)n);
      switch (infotype) {
      case SCTP_RECVV_RCVINFO:
        printf(", sid=%u", info.rcv_sid);
        if (info.rcv_flags & SCTP_UNORDERED) {
          printf(", unordered");
        } else {
          printf(", ssn=%u", info.rcv_ssn);
        }
        printf(", tsn=%u", info.rcv_tsn);
        printf(", ppid=%u.\n", ntohl(info.rcv_ppid));
        break;
      case SCTP_RECVV_NOINFO:
      case SCTP_RECVV_NXTINFO:
      case SCTP_RECVV_RN:
        printf(".\n");
        break;
      default:
        printf(" unknown infotype.\n");
      }
    }
  }

  if (close(sd) < 0) {
    perror("close");
    exit(1);
  }

  return (0);
}
<CODE ENDS>
]]></artwork>
	</figure>
	</section>

	</back>

	</rfc>
	
